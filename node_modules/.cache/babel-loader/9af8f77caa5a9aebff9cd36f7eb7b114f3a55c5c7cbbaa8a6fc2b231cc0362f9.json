{"ast":null,"code":"import { Mesh } from '../core/Mesh.js';\nimport { Transform } from '../core/Transform.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Texture } from '../core/Texture.js';\nimport { Animation } from './Animation.js';\nconst tempMat4 = /* @__PURE__ */new Mat4();\nexport class Skin extends Mesh {\n  constructor(gl, {\n    rig,\n    geometry,\n    program,\n    mode = gl.TRIANGLES\n  } = {}) {\n    super(gl, {\n      geometry,\n      program,\n      mode\n    });\n    this.createBones(rig);\n    this.createBoneTexture();\n    this.animations = [];\n    Object.assign(this.program.uniforms, {\n      boneTexture: {\n        value: this.boneTexture\n      },\n      boneTextureSize: {\n        value: this.boneTextureSize\n      }\n    });\n  }\n  createBones(rig) {\n    // Create root so that can simply update world matrix of whole skeleton\n    this.root = new Transform();\n\n    // Create bones\n    this.bones = [];\n    if (!rig.bones || !rig.bones.length) return;\n    for (let i = 0; i < rig.bones.length; i++) {\n      const bone = new Transform();\n\n      // Set initial values (bind pose)\n      bone.position.fromArray(rig.bindPose.position, i * 3);\n      bone.quaternion.fromArray(rig.bindPose.quaternion, i * 4);\n      bone.scale.fromArray(rig.bindPose.scale, i * 3);\n      this.bones.push(bone);\n    }\n\n    // Once created, set the hierarchy\n    rig.bones.forEach((data, i) => {\n      this.bones[i].name = data.name;\n      if (data.parent === -1) return this.bones[i].setParent(this.root);\n      this.bones[i].setParent(this.bones[data.parent]);\n    });\n\n    // Then update to calculate world matrices\n    this.root.updateMatrixWorld(true);\n\n    // Store inverse of bind pose to calculate differences\n    this.bones.forEach(bone => {\n      bone.bindInverse = new Mat4(...bone.worldMatrix).inverse();\n    });\n  }\n  createBoneTexture() {\n    if (!this.bones.length) return;\n    const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.bones.length * 4)) / Math.LN2)));\n    this.boneMatrices = new Float32Array(size * size * 4);\n    this.boneTextureSize = size;\n    this.boneTexture = new Texture(this.gl, {\n      image: this.boneMatrices,\n      generateMipmaps: false,\n      type: this.gl.FLOAT,\n      internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\n      minFilter: this.gl.NEAREST,\n      magFilter: this.gl.NEAREST,\n      flipY: false,\n      width: size\n    });\n  }\n  addAnimation(data) {\n    const animation = new Animation({\n      objects: this.bones,\n      data\n    });\n    this.animations.push(animation);\n    return animation;\n  }\n  update() {\n    // Calculate combined animation weight\n    let total = 0;\n    this.animations.forEach(animation => total += animation.weight);\n    this.animations.forEach((animation, i) => {\n      // force first animation to set in order to reset frame\n      animation.update(total, i === 0);\n    });\n  }\n  draw({\n    camera\n  } = {}) {\n    // Update world matrices manually, as not part of scene graph\n    this.root.updateMatrixWorld(true);\n\n    // Update bone texture\n    this.bones.forEach((bone, i) => {\n      // Find difference between current and bind pose\n      tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\n      this.boneMatrices.set(tempMat4, i * 16);\n    });\n    if (this.boneTexture) this.boneTexture.needsUpdate = true;\n    super.draw({\n      camera\n    });\n  }\n}","map":{"version":3,"names":["Mesh","Transform","Mat4","Texture","Animation","tempMat4","Skin","constructor","gl","rig","geometry","program","mode","TRIANGLES","createBones","createBoneTexture","animations","Object","assign","uniforms","boneTexture","value","boneTextureSize","root","bones","length","i","bone","position","fromArray","bindPose","quaternion","scale","push","forEach","data","name","parent","setParent","updateMatrixWorld","bindInverse","worldMatrix","inverse","size","Math","max","pow","ceil","log","sqrt","LN2","boneMatrices","Float32Array","image","generateMipmaps","type","FLOAT","internalFormat","renderer","isWebgl2","RGBA32F","RGBA","minFilter","NEAREST","magFilter","flipY","width","addAnimation","animation","objects","update","total","weight","draw","camera","multiply","set","needsUpdate"],"sources":["C:/Users/dudet/Documents/gitexp/CampusEats/node_modules/ogl/src/extras/Skin.js"],"sourcesContent":["import { Mesh } from '../core/Mesh.js';\r\nimport { Transform } from '../core/Transform.js';\r\nimport { Mat4 } from '../math/Mat4.js';\r\nimport { Texture } from '../core/Texture.js';\r\nimport { Animation } from './Animation.js';\r\n\r\nconst tempMat4 = /* @__PURE__ */ new Mat4();\r\n\r\nexport class Skin extends Mesh {\r\n    constructor(gl, { rig, geometry, program, mode = gl.TRIANGLES } = {}) {\r\n        super(gl, { geometry, program, mode });\r\n\r\n        this.createBones(rig);\r\n        this.createBoneTexture();\r\n        this.animations = [];\r\n\r\n        Object.assign(this.program.uniforms, {\r\n            boneTexture: { value: this.boneTexture },\r\n            boneTextureSize: { value: this.boneTextureSize },\r\n        });\r\n    }\r\n\r\n    createBones(rig) {\r\n        // Create root so that can simply update world matrix of whole skeleton\r\n        this.root = new Transform();\r\n\r\n        // Create bones\r\n        this.bones = [];\r\n        if (!rig.bones || !rig.bones.length) return;\r\n        for (let i = 0; i < rig.bones.length; i++) {\r\n            const bone = new Transform();\r\n\r\n            // Set initial values (bind pose)\r\n            bone.position.fromArray(rig.bindPose.position, i * 3);\r\n            bone.quaternion.fromArray(rig.bindPose.quaternion, i * 4);\r\n            bone.scale.fromArray(rig.bindPose.scale, i * 3);\r\n\r\n            this.bones.push(bone);\r\n        }\r\n\r\n        // Once created, set the hierarchy\r\n        rig.bones.forEach((data, i) => {\r\n            this.bones[i].name = data.name;\r\n            if (data.parent === -1) return this.bones[i].setParent(this.root);\r\n            this.bones[i].setParent(this.bones[data.parent]);\r\n        });\r\n\r\n        // Then update to calculate world matrices\r\n        this.root.updateMatrixWorld(true);\r\n\r\n        // Store inverse of bind pose to calculate differences\r\n        this.bones.forEach((bone) => {\r\n            bone.bindInverse = new Mat4(...bone.worldMatrix).inverse();\r\n        });\r\n    }\r\n\r\n    createBoneTexture() {\r\n        if (!this.bones.length) return;\r\n        const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.bones.length * 4)) / Math.LN2)));\r\n        this.boneMatrices = new Float32Array(size * size * 4);\r\n        this.boneTextureSize = size;\r\n        this.boneTexture = new Texture(this.gl, {\r\n            image: this.boneMatrices,\r\n            generateMipmaps: false,\r\n            type: this.gl.FLOAT,\r\n            internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\r\n            minFilter: this.gl.NEAREST,\r\n            magFilter: this.gl.NEAREST,\r\n            flipY: false,\r\n            width: size,\r\n        });\r\n    }\r\n\r\n    addAnimation(data) {\r\n        const animation = new Animation({ objects: this.bones, data });\r\n        this.animations.push(animation);\r\n        return animation;\r\n    }\r\n\r\n    update() {\r\n        // Calculate combined animation weight\r\n        let total = 0;\r\n        this.animations.forEach((animation) => (total += animation.weight));\r\n\r\n        this.animations.forEach((animation, i) => {\r\n            // force first animation to set in order to reset frame\r\n            animation.update(total, i === 0);\r\n        });\r\n    }\r\n\r\n    draw({ camera } = {}) {\r\n        // Update world matrices manually, as not part of scene graph\r\n        this.root.updateMatrixWorld(true);\r\n\r\n        // Update bone texture\r\n        this.bones.forEach((bone, i) => {\r\n            // Find difference between current and bind pose\r\n            tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\r\n            this.boneMatrices.set(tempMat4, i * 16);\r\n        });\r\n        if (this.boneTexture) this.boneTexture.needsUpdate = true;\r\n\r\n        super.draw({ camera });\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}