{"ast":null,"code":"// deno-lint-ignore-file no-this-alias\nimport { isArray, isBigNumber, isCollection, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is.js';\nimport { arraySize, getArrayDataType, processSizesWildcard, reshape, resize, unsqueeze, validate, validateIndex, broadcastTo, get } from '../../utils/array.js';\nimport { format } from '../../utils/string.js';\nimport { isInteger } from '../../utils/number.js';\nimport { clone, deepStrictEqual } from '../../utils/object.js';\nimport { DimensionError } from '../../error/DimensionError.js';\nimport { factory } from '../../utils/factory.js';\nimport { optimizeCallback } from '../../utils/optimizeCallback.js';\nvar name = 'DenseMatrix';\nvar dependencies = ['Matrix', 'config'];\nexport var createDenseMatrixClass = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Matrix,\n    config\n  } = _ref;\n  /**\r\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\r\n   * @class DenseMatrix\r\n   * @enum {{ value, index: number[] }}\r\n   */\n  function DenseMatrix(data, datatype) {\n    if (!(this instanceof DenseMatrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n    if (datatype && !isString(datatype)) {\n      throw new Error('Invalid datatype: ' + datatype);\n    }\n    if (isMatrix(data)) {\n      // check data is a DenseMatrix\n      if (data.type === 'DenseMatrix') {\n        // clone data & size\n        this._data = clone(data._data);\n        this._size = clone(data._size);\n        this._datatype = datatype || data._datatype;\n      } else {\n        // build data from existing matrix\n        this._data = data.toArray();\n        this._size = data.size();\n        this._datatype = datatype || data._datatype;\n      }\n    } else if (data && isArray(data.data) && isArray(data.size)) {\n      // initialize fields from JSON representation\n      this._data = data.data;\n      this._size = data.size;\n      // verify the dimensions of the array\n      validate(this._data, this._size);\n      this._datatype = datatype || data.datatype;\n    } else if (isArray(data)) {\n      // replace nested Matrices with Arrays\n      this._data = preprocess(data);\n      // get the dimensions of the array\n      this._size = arraySize(this._data);\n      // verify the dimensions of the array, TODO: compute size while processing array\n      validate(this._data, this._size);\n      // data type unknown\n      this._datatype = datatype;\n    } else if (data) {\n      // unsupported type\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\n    } else {\n      // nothing provided\n      this._data = [];\n      this._size = [0];\n      this._datatype = datatype;\n    }\n  }\n  DenseMatrix.prototype = new Matrix();\n\n  /**\r\n   * Create a new DenseMatrix\r\n   */\n  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n\n  /**\r\n   * Attach type information\r\n   */\n  Object.defineProperty(DenseMatrix, 'name', {\n    value: 'DenseMatrix'\n  });\n  DenseMatrix.prototype.constructor = DenseMatrix;\n  DenseMatrix.prototype.type = 'DenseMatrix';\n  DenseMatrix.prototype.isDenseMatrix = true;\n\n  /**\r\n   * Get the matrix type\r\n   *\r\n   * Usage:\r\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\r\n   *\r\n   * @memberOf DenseMatrix\r\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\r\n   */\n  DenseMatrix.prototype.getDataType = function () {\n    return getArrayDataType(this._data, typeOf);\n  };\n\n  /**\r\n   * Get the storage format used by the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.storage()  // retrieve storage format\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @return {string}           The storage format.\r\n   */\n  DenseMatrix.prototype.storage = function () {\n    return 'dense';\n  };\n\n  /**\r\n   * Get the datatype of the data stored in the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.datatype()   // retrieve matrix datatype\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @return {string}           The datatype.\r\n   */\n  DenseMatrix.prototype.datatype = function () {\n    return this._datatype;\n  };\n\n  /**\r\n   * Create a new DenseMatrix\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @param {string} [datatype]\r\n   */\n  DenseMatrix.prototype.create = function (data, datatype) {\n    return new DenseMatrix(data, datatype);\n  };\n\n  /**\r\n   * Get a subset of the matrix, or replace a subset of the matrix.\r\n   *\r\n   * Usage:\r\n   *     const subset = matrix.subset(index)               // retrieve subset\r\n   *     const value = matrix.subset(index, replacement)   // replace subset\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {Index} index\r\n   * @param {Array | Matrix | *} [replacement]\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be filled with zeros.\r\n   */\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\n    switch (arguments.length) {\n      case 1:\n        return _get(this, index);\n\n      // intentional fall through\n      case 2:\n      case 3:\n        return _set(this, index, replacement, defaultValue);\n      default:\n        throw new SyntaxError('Wrong number of arguments');\n    }\n  };\n\n  /**\r\n   * Get a single element from the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {number[]} index   Zero-based index\r\n   * @return {*} value\r\n   */\n  DenseMatrix.prototype.get = function (index) {\n    return get(this._data, index);\n  };\n\n  /**\r\n   * Replace a single element in the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {number[]} index   Zero-based index\r\n   * @param {*} value\r\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be left undefined.\r\n   * @return {DenseMatrix} self\r\n   */\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\n    if (!isArray(index)) {\n      throw new TypeError('Array expected');\n    }\n    if (index.length < this._size.length) {\n      throw new DimensionError(index.length, this._size.length, '<');\n    }\n    var i, ii, indexI;\n\n    // enlarge matrix when needed\n    var size = index.map(function (i) {\n      return i + 1;\n    });\n    _fit(this, size, defaultValue);\n\n    // traverse over the dimensions\n    var data = this._data;\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\n      indexI = index[i];\n      validateIndex(indexI, data.length);\n      data = data[indexI];\n    }\n\n    // set new value\n    indexI = index[index.length - 1];\n    validateIndex(indexI, data.length);\n    data[indexI] = value;\n    return this;\n  };\n\n  /**\r\n   * Get a submatrix of this matrix\r\n   * @memberof DenseMatrix\r\n   * @param {DenseMatrix} matrix\r\n   * @param {Index} index   Zero-based index\r\n   * @private\r\n   */\n  function _get(matrix, index) {\n    if (!isIndex(index)) {\n      throw new TypeError('Invalid index');\n    }\n    var isScalar = config.legacySubset ? index.size().every(idx => idx === 1) : index.isScalar();\n    if (isScalar) {\n      // return a scalar\n      return matrix.get(index.min());\n    } else {\n      // validate dimensions\n      var size = index.size();\n      if (size.length !== matrix._size.length) {\n        throw new DimensionError(size.length, matrix._size.length);\n      }\n\n      // validate if any of the ranges in the index is out of range\n      var min = index.min();\n      var max = index.max();\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\n        validateIndex(min[i], matrix._size[i]);\n        validateIndex(max[i], matrix._size[i]);\n      }\n\n      // retrieve submatrix\n      var returnMatrix = new DenseMatrix();\n      var submatrix = _getSubmatrix(matrix._data, index);\n      returnMatrix._size = submatrix.size;\n      returnMatrix._datatype = matrix._datatype;\n      returnMatrix._data = submatrix.data;\n      return config.legacySubset ? returnMatrix.reshape(index.size()) : returnMatrix;\n    }\n  }\n\n  /**\r\n   * Get a submatrix of a multi dimensional matrix.\r\n   * Index is not checked for correct number or length of dimensions.\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @param {Index} index\r\n   * @return {Array} submatrix\r\n   * @private\r\n   */\n  function _getSubmatrix(data, index) {\n    var maxDepth = index.size().length - 1;\n    var size = Array(maxDepth);\n    return {\n      data: getSubmatrixRecursive(data),\n      size: size.filter(x => x !== null)\n    };\n    function getSubmatrixRecursive(data) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var dims = index.dimension(depth);\n      function _mapIndex(dim, callback) {\n        // applies a callback for when the index is a Number or a Matrix\n        if (isNumber(dim)) return callback(dim);else return dim.map(callback).valueOf();\n      }\n      if (isNumber(dims)) {\n        size[depth] = null;\n      } else {\n        size[depth] = dims.size()[0];\n      }\n      if (depth < maxDepth) {\n        return _mapIndex(dims, dimIndex => {\n          validateIndex(dimIndex, data.length);\n          return getSubmatrixRecursive(data[dimIndex], depth + 1);\n        });\n      } else {\n        return _mapIndex(dims, dimIndex => {\n          validateIndex(dimIndex, data.length);\n          return data[dimIndex];\n        });\n      }\n    }\n  }\n\n  /**\r\n   * Replace a submatrix in this matrix\r\n   * Indexes are zero-based.\r\n   * @memberof DenseMatrix\r\n   * @param {DenseMatrix} matrix\r\n   * @param {Index} index\r\n   * @param {DenseMatrix | Array | *} submatrix\r\n   * @param {*} defaultValue          Default value, filled in on new entries when\r\n   *                                  the matrix is resized.\r\n   * @return {DenseMatrix} matrix\r\n   * @private\r\n   */\n  function _set(matrix, index, submatrix, defaultValue) {\n    if (!index || index.isIndex !== true) {\n      throw new TypeError('Invalid index');\n    }\n\n    // get index size and check whether the index contains a single value\n    var iSize = index.size();\n    var isScalar = index.isScalar();\n\n    // calculate the size of the submatrix, and convert it into an Array if needed\n    var submatrixSize;\n    if (isMatrix(submatrix)) {\n      submatrixSize = submatrix.size();\n      submatrix = submatrix.valueOf();\n    } else {\n      submatrixSize = arraySize(submatrix);\n    }\n    if (isScalar) {\n      // set a scalar\n\n      // check whether submatrix is a scalar\n      if (submatrixSize.length !== 0) {\n        throw new TypeError('Scalar expected');\n      }\n      matrix.set(index.min(), submatrix, defaultValue);\n    } else {\n      // set a submatrix\n\n      // broadcast submatrix\n      if (!deepStrictEqual(submatrixSize, iSize)) {\n        if (submatrixSize.length === 0) {\n          submatrix = broadcastTo([submatrix], iSize);\n        } else {\n          try {\n            submatrix = broadcastTo(submatrix, iSize);\n          } catch (error) {}\n        }\n        submatrixSize = arraySize(submatrix);\n      }\n\n      // validate dimensions\n      if (iSize.length < matrix._size.length) {\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\n      }\n      if (submatrixSize.length < iSize.length) {\n        // calculate number of missing outer dimensions\n        var i = 0;\n        var outer = 0;\n        while (iSize[i] === 1 && submatrixSize[i] === 1) {\n          i++;\n        }\n        while (iSize[i] === 1) {\n          outer++;\n          i++;\n        }\n\n        // unsqueeze both outer and inner dimensions\n        submatrix = unsqueeze(submatrix, iSize.length, outer, submatrixSize);\n      }\n\n      // check whether the size of the submatrix matches the index size\n      if (!deepStrictEqual(iSize, submatrixSize)) {\n        throw new DimensionError(iSize, submatrixSize, '>');\n      }\n\n      // enlarge matrix when needed\n      var size = index.max().map(function (i) {\n        return i + 1;\n      });\n      _fit(matrix, size, defaultValue);\n\n      // insert the sub matrix\n      _setSubmatrix(matrix._data, index, submatrix);\n    }\n    return matrix;\n  }\n\n  /**\r\n   * Replace a submatrix of a multi dimensional matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @param {Index} index\r\n   * @param {Array} submatrix\r\n   * @private\r\n   */\n  function _setSubmatrix(data, index, submatrix) {\n    var maxDepth = index.size().length - 1;\n    setSubmatrixRecursive(data, submatrix);\n    function setSubmatrixRecursive(data, submatrix) {\n      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var range = index.dimension(depth);\n      var recursiveCallback = (rangeIndex, i) => {\n        validateIndex(rangeIndex, data.length);\n        setSubmatrixRecursive(data[rangeIndex], submatrix[i[0]], depth + 1);\n      };\n      var finalCallback = (rangeIndex, i) => {\n        validateIndex(rangeIndex, data.length);\n        data[rangeIndex] = submatrix[i[0]];\n      };\n      if (depth < maxDepth) {\n        if (isNumber(range)) recursiveCallback(range, [0]);else range.forEach(recursiveCallback);\n      } else {\n        if (isNumber(range)) finalCallback(range, [0]);else range.forEach(finalCallback);\n      }\n    }\n  }\n\n  /**\r\n   * Resize the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (resize in place).\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number[] || Matrix} size The new size the matrix should have.\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\r\n   *                                  If not provided, the matrix elements will\r\n   *                                  be filled with zeros.\r\n   * @param {boolean} [copy]          Return a resized copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The resized matrix\r\n   */\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\n    // validate arguments\n    if (!isCollection(size)) {\n      throw new TypeError('Array or Matrix expected');\n    }\n\n    // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\n    var sizeArray = size.valueOf().map(value => {\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\n    });\n\n    // matrix to resize\n    var m = copy ? this.clone() : this;\n    // resize matrix\n    return _resize(m, sizeArray, defaultValue);\n  };\n  function _resize(matrix, size, defaultValue) {\n    // check size\n    if (size.length === 0) {\n      // first value in matrix\n      var v = matrix._data;\n      // go deep\n      while (isArray(v)) {\n        v = v[0];\n      }\n      return v;\n    }\n    // resize matrix\n    matrix._size = size.slice(0); // copy the array\n    matrix._data = resize(matrix._data, matrix._size, defaultValue);\n    // return matrix\n    return matrix;\n  }\n\n  /**\r\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\r\n   *\r\n   * NOTE: This might be better suited to copy by default, instead of modifying\r\n   *       in place. For now, it operates in place to remain consistent with\r\n   *       resize().\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number[]} size           The new size the matrix should have.\r\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The reshaped matrix\r\n   */\n  DenseMatrix.prototype.reshape = function (size, copy) {\n    var m = copy ? this.clone() : this;\n    m._data = reshape(m._data, size);\n    var currentLength = m._size.reduce((length, size) => length * size);\n    m._size = processSizesWildcard(size, currentLength);\n    return m;\n  };\n\n  /**\r\n   * Enlarge the matrix when it is smaller than given size.\r\n   * If the matrix is larger or equal sized, nothing is done.\r\n   * @memberof DenseMatrix\r\n   * @param {DenseMatrix} matrix           The matrix to be resized\r\n   * @param {number[]} size\r\n   * @param {*} defaultValue          Default value, filled in on new entries.\r\n   * @private\r\n   */\n  function _fit(matrix, size, defaultValue) {\n    var\n    // copy the array\n    newSize = matrix._size.slice(0);\n    var changed = false;\n\n    // add dimensions when needed\n    while (newSize.length < size.length) {\n      newSize.push(0);\n      changed = true;\n    }\n\n    // enlarge size when needed\n    for (var i = 0, ii = size.length; i < ii; i++) {\n      if (size[i] > newSize[i]) {\n        newSize[i] = size[i];\n        changed = true;\n      }\n    }\n    if (changed) {\n      // resize only when size is changed\n      _resize(matrix, newSize, defaultValue);\n    }\n  }\n\n  /**\r\n   * Create a clone of the matrix\r\n   * @memberof DenseMatrix\r\n   * @return {DenseMatrix} clone\r\n   */\n  DenseMatrix.prototype.clone = function () {\n    var m = new DenseMatrix({\n      data: clone(this._data),\n      size: clone(this._size),\n      datatype: this._datatype\n    });\n    return m;\n  };\n\n  /**\r\n   * Retrieve the size of the matrix.\r\n   * @memberof DenseMatrix\r\n   * @returns {number[]} size\r\n   */\n  DenseMatrix.prototype.size = function () {\n    return this._size.slice(0); // return a clone of _size\n  };\n\n  /**\r\n   * Create a new matrix with the results of the callback function executed on\r\n   * each entry of the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   * @param {boolean} skipZeros   If true, the callback function is invoked only for non-zero entries\r\n   * @param {boolean} isUnary     If true, the callback function is invoked with one parameter\r\n   *\r\n   * @return {DenseMatrix} matrix\r\n   */\n  DenseMatrix.prototype.map = function (callback) {\n    var skipZeros = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var isUnary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var me = this;\n    var maxDepth = me._size.length - 1;\n    if (maxDepth < 0) return me.clone();\n    var fastCallback = optimizeCallback(callback, me, 'map', isUnary);\n    var fastCallbackFn = fastCallback.fn;\n    var result = me.create(undefined, me._datatype);\n    result._size = me._size;\n    if (isUnary || fastCallback.isUnary) {\n      result._data = iterateUnary(me._data);\n      return result;\n    }\n    if (maxDepth === 0) {\n      var inputData = me.valueOf();\n      var data = Array(inputData.length);\n      for (var i = 0; i < inputData.length; i++) {\n        data[i] = fastCallbackFn(inputData[i], [i], me);\n      }\n      result._data = data;\n      return result;\n    }\n    var index = [];\n    result._data = iterate(me._data);\n    return result;\n    function iterate(data) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var result = Array(data.length);\n      if (depth < maxDepth) {\n        for (var _i = 0; _i < data.length; _i++) {\n          index[depth] = _i;\n          result[_i] = iterate(data[_i], depth + 1);\n        }\n      } else {\n        for (var _i2 = 0; _i2 < data.length; _i2++) {\n          index[depth] = _i2;\n          result[_i2] = fastCallbackFn(data[_i2], index.slice(), me);\n        }\n      }\n      return result;\n    }\n    function iterateUnary(data) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var result = Array(data.length);\n      if (depth < maxDepth) {\n        for (var _i3 = 0; _i3 < data.length; _i3++) {\n          result[_i3] = iterateUnary(data[_i3], depth + 1);\n        }\n      } else {\n        for (var _i4 = 0; _i4 < data.length; _i4++) {\n          result[_i4] = fastCallbackFn(data[_i4]);\n        }\n      }\n      return result;\n    }\n  };\n\n  /**\r\n   * Execute a callback function on each entry of the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   * @param {boolean} skipZeros   If true, the callback function is invoked only for non-zero entries\r\n   * @param {boolean} isUnary     If true, the callback function is invoked with one parameter\r\n   */\n  DenseMatrix.prototype.forEach = function (callback) {\n    var skipZeros = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var isUnary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var me = this;\n    var maxDepth = me._size.length - 1;\n    if (maxDepth < 0) return;\n    var fastCallback = optimizeCallback(callback, me, 'map', isUnary);\n    var fastCallbackFn = fastCallback.fn;\n    if (isUnary || fastCallback.isUnary) {\n      iterateUnary(me._data);\n      return;\n    }\n    if (maxDepth === 0) {\n      for (var i = 0; i < me._data.length; i++) {\n        fastCallbackFn(me._data[i], [i], me);\n      }\n      return;\n    }\n    var index = [];\n    iterate(me._data);\n    function iterate(data) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (depth < maxDepth) {\n        for (var _i5 = 0; _i5 < data.length; _i5++) {\n          index[depth] = _i5;\n          iterate(data[_i5], depth + 1);\n        }\n      } else {\n        for (var _i6 = 0; _i6 < data.length; _i6++) {\n          index[depth] = _i6;\n          fastCallbackFn(data[_i6], index.slice(), me);\n        }\n      }\n    }\n    function iterateUnary(data) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (depth < maxDepth) {\n        for (var _i7 = 0; _i7 < data.length; _i7++) {\n          iterateUnary(data[_i7], depth + 1);\n        }\n      } else {\n        for (var _i8 = 0; _i8 < data.length; _i8++) {\n          fastCallbackFn(data[_i8]);\n        }\n      }\n    }\n  };\n\n  /**\r\n   * Iterate over the matrix elements\r\n   * @return {Iterable<{ value, index: number[] }>}\r\n   */\n  DenseMatrix.prototype[Symbol.iterator] = function* () {\n    var maxDepth = this._size.length - 1;\n    if (maxDepth < 0) {\n      return;\n    }\n    if (maxDepth === 0) {\n      for (var i = 0; i < this._data.length; i++) {\n        yield {\n          value: this._data[i],\n          index: [i]\n        };\n      }\n      return;\n    }\n\n    // Multi-dimensional matrix: iterate over all elements\n    var index = Array(maxDepth + 1).fill(0);\n    var totalElements = this._size.reduce((a, b) => a * b, 1);\n    for (var count = 0; count < totalElements; count++) {\n      // Traverse to the current element using indices\n      var current = this._data;\n      for (var d = 0; d < maxDepth; d++) {\n        current = current[index[d]];\n      }\n      yield {\n        value: current[index[maxDepth]],\n        index: index.slice()\n      };\n\n      // Increment indices for next element\n      for (var _d = maxDepth; _d >= 0; _d--) {\n        index[_d]++;\n        if (index[_d] < this._size[_d]) break;\n        index[_d] = 0;\n      }\n    }\n  };\n\n  /**\r\n   * Returns an array containing the rows of a 2D matrix\r\n   * @returns {Array<Matrix>}\r\n   */\n  DenseMatrix.prototype.rows = function () {\n    var result = [];\n    var s = this.size();\n    if (s.length !== 2) {\n      throw new TypeError('Rows can only be returned for a 2D matrix.');\n    }\n    var data = this._data;\n    for (var row of data) {\n      result.push(new DenseMatrix([row], this._datatype));\n    }\n    return result;\n  };\n\n  /**\r\n   * Returns an array containing the columns of a 2D matrix\r\n   * @returns {Array<Matrix>}\r\n   */\n  DenseMatrix.prototype.columns = function () {\n    var _this = this;\n    var result = [];\n    var s = this.size();\n    if (s.length !== 2) {\n      throw new TypeError('Rows can only be returned for a 2D matrix.');\n    }\n    var data = this._data;\n    var _loop = function _loop(i) {\n      var col = data.map(row => [row[i]]);\n      result.push(new DenseMatrix(col, _this._datatype));\n    };\n    for (var i = 0; i < s[1]; i++) {\n      _loop(i);\n    }\n    return result;\n  };\n\n  /**\r\n   * Create an Array with a copy of the data of the DenseMatrix\r\n   * @memberof DenseMatrix\r\n   * @returns {Array} array\r\n   */\n  DenseMatrix.prototype.toArray = function () {\n    return clone(this._data);\n  };\n\n  /**\r\n   * Get the primitive value of the DenseMatrix: a multidimensional array\r\n   * @memberof DenseMatrix\r\n   * @returns {Array} array\r\n   */\n  DenseMatrix.prototype.valueOf = function () {\n    return this._data;\n  };\n\n  /**\r\n   * Get a string representation of the matrix, with optional formatting options.\r\n   * @memberof DenseMatrix\r\n   * @param {Object | number | Function} [options]  Formatting options. See\r\n   *                                                lib/utils/number:format for a\r\n   *                                                description of the available\r\n   *                                                options.\r\n   * @returns {string} str\r\n   */\n  DenseMatrix.prototype.format = function (options) {\n    return format(this._data, options);\n  };\n\n  /**\r\n   * Get a string representation of the matrix\r\n   * @memberof DenseMatrix\r\n   * @returns {string} str\r\n   */\n  DenseMatrix.prototype.toString = function () {\n    return format(this._data);\n  };\n\n  /**\r\n   * Get a JSON representation of the matrix\r\n   * @memberof DenseMatrix\r\n   * @returns {Object}\r\n   */\n  DenseMatrix.prototype.toJSON = function () {\n    return {\n      mathjs: 'DenseMatrix',\n      data: this._data,\n      size: this._size,\n      datatype: this._datatype\n    };\n  };\n\n  /**\r\n   * Get the kth Matrix diagonal.\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\r\n   *\r\n   * @returns {Matrix}                     The matrix with the diagonal values.\r\n   */\n  DenseMatrix.prototype.diagonal = function (k) {\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      }\n      // is must be an integer\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0;\n\n    // rows & columns\n    var rows = this._size[0];\n    var columns = this._size[1];\n\n    // number diagonal values\n    var n = Math.min(rows - kSub, columns - kSuper);\n\n    // x is a matrix get diagonal from matrix\n    var data = [];\n\n    // loop rows\n    for (var i = 0; i < n; i++) {\n      data[i] = this._data[i + kSub][i + kSuper];\n    }\n\n    // create DenseMatrix\n    return new DenseMatrix({\n      data,\n      size: [n],\n      datatype: this._datatype\n    });\n  };\n\n  /**\r\n   * Create a diagonal matrix.\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {Array} size                     The matrix size.\r\n   * @param {number | Matrix | Array } value The values for the diagonal.\r\n   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.\r\n   * @param {number} [defaultValue]          The default value for non-diagonal\r\n   * @param {string} [datatype]              The datatype for the diagonal\r\n   *\r\n   * @returns {DenseMatrix}\r\n   */\n  DenseMatrix.diagonal = function (size, value, k, defaultValue) {\n    if (!isArray(size)) {\n      throw new TypeError('Array expected, size parameter');\n    }\n    if (size.length !== 2) {\n      throw new Error('Only two dimensions matrix are supported');\n    }\n\n    // map size & validate\n    size = size.map(function (s) {\n      // check it is a big number\n      if (isBigNumber(s)) {\n        // convert it\n        s = s.toNumber();\n      }\n      // validate arguments\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\n        throw new Error('Size values must be positive integers');\n      }\n      return s;\n    });\n\n    // validate k if any\n    if (k) {\n      // convert BigNumber to a number\n      if (isBigNumber(k)) {\n        k = k.toNumber();\n      }\n      // is must be an integer\n      if (!isNumber(k) || !isInteger(k)) {\n        throw new TypeError('The parameter k must be an integer number');\n      }\n    } else {\n      // default value\n      k = 0;\n    }\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0;\n\n    // rows and columns\n    var rows = size[0];\n    var columns = size[1];\n\n    // number of non-zero items\n    var n = Math.min(rows - kSub, columns - kSuper);\n\n    // value extraction function\n    var _value;\n\n    // check value\n    if (isArray(value)) {\n      // validate array\n      if (value.length !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid value array length');\n      }\n      // define function\n      _value = function _value(i) {\n        // return value @ i\n        return value[i];\n      };\n    } else if (isMatrix(value)) {\n      // matrix size\n      var ms = value.size();\n      // validate matrix\n      if (ms.length !== 1 || ms[0] !== n) {\n        // number of values in array must be n\n        throw new Error('Invalid matrix length');\n      }\n      // define function\n      _value = function _value(i) {\n        // return value @ i\n        return value.get([i]);\n      };\n    } else {\n      // define function\n      _value = function _value() {\n        // return value\n        return value;\n      };\n    }\n\n    // discover default value if needed\n    if (!defaultValue) {\n      // check first value in array\n      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero\n      : 0;\n    }\n\n    // empty array\n    var data = [];\n\n    // check we need to resize array\n    if (size.length > 0) {\n      // resize array\n      data = resize(data, size, defaultValue);\n      // fill diagonal\n      for (var d = 0; d < n; d++) {\n        data[d + kSub][d + kSuper] = _value(d);\n      }\n    }\n\n    // create DenseMatrix\n    return new DenseMatrix({\n      data,\n      size: [rows, columns]\n    });\n  };\n\n  /**\r\n   * Generate a matrix from a JSON object\r\n   * @memberof DenseMatrix\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"DenseMatrix\", data: [], size: []}`,\r\n   *                       where mathjs is optional\r\n   * @returns {DenseMatrix}\r\n   */\n  DenseMatrix.fromJSON = function (json) {\n    return new DenseMatrix(json);\n  };\n\n  /**\r\n   * Swap rows i and j in Matrix.\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number} i       Matrix row index 1\r\n   * @param {number} j       Matrix row index 2\r\n   *\r\n   * @return {Matrix}        The matrix reference\r\n   */\n  DenseMatrix.prototype.swapRows = function (i, j) {\n    // check index\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\n      throw new Error('Row index must be positive integers');\n    }\n    // check dimensions\n    if (this._size.length !== 2) {\n      throw new Error('Only two dimensional matrix is supported');\n    }\n    // validate index\n    validateIndex(i, this._size[0]);\n    validateIndex(j, this._size[0]);\n\n    // swap rows\n    DenseMatrix._swapRows(i, j, this._data);\n    // return current instance\n    return this;\n  };\n\n  /**\r\n   * Swap rows i and j in Dense Matrix data structure.\r\n   *\r\n   * @param {number} i       Matrix row index 1\r\n   * @param {number} j       Matrix row index 2\r\n   * @param {Array} data     Matrix data\r\n   */\n  DenseMatrix._swapRows = function (i, j, data) {\n    // swap values i <-> j\n    var vi = data[i];\n    data[i] = data[j];\n    data[j] = vi;\n  };\n\n  /**\r\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\r\n   * Matrices. Clones all (nested) Arrays, and replaces all nested Matrices with Arrays\r\n   * @memberof DenseMatrix\r\n   * @param {Array | Matrix} data\r\n   * @return {Array} data\r\n   */\n  function preprocess(data) {\n    if (isMatrix(data)) {\n      return preprocess(data.valueOf());\n    }\n    if (isArray(data)) {\n      return data.map(preprocess);\n    }\n    return data;\n  }\n  return DenseMatrix;\n}, {\n  isClass: true\n});","map":{"version":3,"names":["isArray","isBigNumber","isCollection","isIndex","isMatrix","isNumber","isString","typeOf","arraySize","getArrayDataType","processSizesWildcard","reshape","resize","unsqueeze","validate","validateIndex","broadcastTo","get","format","isInteger","clone","deepStrictEqual","DimensionError","factory","optimizeCallback","name","dependencies","createDenseMatrixClass","_ref","Matrix","config","DenseMatrix","data","datatype","SyntaxError","Error","type","_data","_size","_datatype","toArray","size","preprocess","TypeError","prototype","createDenseMatrix","Object","defineProperty","value","constructor","isDenseMatrix","getDataType","storage","create","subset","index","replacement","defaultValue","arguments","length","_get","_set","set","i","ii","indexI","map","_fit","matrix","isScalar","legacySubset","every","idx","min","max","returnMatrix","submatrix","_getSubmatrix","maxDepth","Array","getSubmatrixRecursive","filter","x","depth","undefined","dims","dimension","_mapIndex","dim","callback","valueOf","dimIndex","iSize","submatrixSize","error","outer","_setSubmatrix","setSubmatrixRecursive","range","recursiveCallback","rangeIndex","finalCallback","forEach","copy","sizeArray","m","_resize","v","slice","currentLength","reduce","newSize","changed","push","skipZeros","isUnary","me","fastCallback","fastCallbackFn","fn","result","iterateUnary","inputData","iterate","_i","_i2","_i3","_i4","_i5","_i6","_i7","_i8","Symbol","iterator","fill","totalElements","a","b","count","current","d","_d","rows","s","row","columns","_this","_loop","col","options","toString","toJSON","mathjs","diagonal","k","toNumber","kSuper","kSub","n","Math","_value","ms","mul","fromJSON","json","swapRows","j","_swapRows","vi","isClass"],"sources":["C:/Users/dudet/Documents/gitexp/CampusEats/node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js"],"sourcesContent":["// deno-lint-ignore-file no-this-alias\r\nimport { isArray, isBigNumber, isCollection, isIndex, isMatrix, isNumber, isString, typeOf } from '../../utils/is.js';\r\nimport { arraySize, getArrayDataType, processSizesWildcard, reshape, resize, unsqueeze, validate, validateIndex, broadcastTo, get } from '../../utils/array.js';\r\nimport { format } from '../../utils/string.js';\r\nimport { isInteger } from '../../utils/number.js';\r\nimport { clone, deepStrictEqual } from '../../utils/object.js';\r\nimport { DimensionError } from '../../error/DimensionError.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { optimizeCallback } from '../../utils/optimizeCallback.js';\r\nvar name = 'DenseMatrix';\r\nvar dependencies = ['Matrix', 'config'];\r\nexport var createDenseMatrixClass = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Matrix,\r\n    config\r\n  } = _ref;\r\n  /**\r\n   * Dense Matrix implementation. A regular, dense matrix, supporting multi-dimensional matrices. This is the default matrix type.\r\n   * @class DenseMatrix\r\n   * @enum {{ value, index: number[] }}\r\n   */\r\n  function DenseMatrix(data, datatype) {\r\n    if (!(this instanceof DenseMatrix)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n    if (datatype && !isString(datatype)) {\r\n      throw new Error('Invalid datatype: ' + datatype);\r\n    }\r\n    if (isMatrix(data)) {\r\n      // check data is a DenseMatrix\r\n      if (data.type === 'DenseMatrix') {\r\n        // clone data & size\r\n        this._data = clone(data._data);\r\n        this._size = clone(data._size);\r\n        this._datatype = datatype || data._datatype;\r\n      } else {\r\n        // build data from existing matrix\r\n        this._data = data.toArray();\r\n        this._size = data.size();\r\n        this._datatype = datatype || data._datatype;\r\n      }\r\n    } else if (data && isArray(data.data) && isArray(data.size)) {\r\n      // initialize fields from JSON representation\r\n      this._data = data.data;\r\n      this._size = data.size;\r\n      // verify the dimensions of the array\r\n      validate(this._data, this._size);\r\n      this._datatype = datatype || data.datatype;\r\n    } else if (isArray(data)) {\r\n      // replace nested Matrices with Arrays\r\n      this._data = preprocess(data);\r\n      // get the dimensions of the array\r\n      this._size = arraySize(this._data);\r\n      // verify the dimensions of the array, TODO: compute size while processing array\r\n      validate(this._data, this._size);\r\n      // data type unknown\r\n      this._datatype = datatype;\r\n    } else if (data) {\r\n      // unsupported type\r\n      throw new TypeError('Unsupported type of data (' + typeOf(data) + ')');\r\n    } else {\r\n      // nothing provided\r\n      this._data = [];\r\n      this._size = [0];\r\n      this._datatype = datatype;\r\n    }\r\n  }\r\n  DenseMatrix.prototype = new Matrix();\r\n\r\n  /**\r\n   * Create a new DenseMatrix\r\n   */\r\n  DenseMatrix.prototype.createDenseMatrix = function (data, datatype) {\r\n    return new DenseMatrix(data, datatype);\r\n  };\r\n\r\n  /**\r\n   * Attach type information\r\n   */\r\n  Object.defineProperty(DenseMatrix, 'name', {\r\n    value: 'DenseMatrix'\r\n  });\r\n  DenseMatrix.prototype.constructor = DenseMatrix;\r\n  DenseMatrix.prototype.type = 'DenseMatrix';\r\n  DenseMatrix.prototype.isDenseMatrix = true;\r\n\r\n  /**\r\n   * Get the matrix type\r\n   *\r\n   * Usage:\r\n   *    const matrixType = matrix.getDataType()  // retrieves the matrix type\r\n   *\r\n   * @memberOf DenseMatrix\r\n   * @return {string}   type information; if multiple types are found from the Matrix, it will return \"mixed\"\r\n   */\r\n  DenseMatrix.prototype.getDataType = function () {\r\n    return getArrayDataType(this._data, typeOf);\r\n  };\r\n\r\n  /**\r\n   * Get the storage format used by the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.storage()  // retrieve storage format\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @return {string}           The storage format.\r\n   */\r\n  DenseMatrix.prototype.storage = function () {\r\n    return 'dense';\r\n  };\r\n\r\n  /**\r\n   * Get the datatype of the data stored in the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.datatype()   // retrieve matrix datatype\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @return {string}           The datatype.\r\n   */\r\n  DenseMatrix.prototype.datatype = function () {\r\n    return this._datatype;\r\n  };\r\n\r\n  /**\r\n   * Create a new DenseMatrix\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @param {string} [datatype]\r\n   */\r\n  DenseMatrix.prototype.create = function (data, datatype) {\r\n    return new DenseMatrix(data, datatype);\r\n  };\r\n\r\n  /**\r\n   * Get a subset of the matrix, or replace a subset of the matrix.\r\n   *\r\n   * Usage:\r\n   *     const subset = matrix.subset(index)               // retrieve subset\r\n   *     const value = matrix.subset(index, replacement)   // replace subset\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {Index} index\r\n   * @param {Array | Matrix | *} [replacement]\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be filled with zeros.\r\n   */\r\n  DenseMatrix.prototype.subset = function (index, replacement, defaultValue) {\r\n    switch (arguments.length) {\r\n      case 1:\r\n        return _get(this, index);\r\n\r\n      // intentional fall through\r\n      case 2:\r\n      case 3:\r\n        return _set(this, index, replacement, defaultValue);\r\n      default:\r\n        throw new SyntaxError('Wrong number of arguments');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Get a single element from the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {number[]} index   Zero-based index\r\n   * @return {*} value\r\n   */\r\n  DenseMatrix.prototype.get = function (index) {\r\n    return get(this._data, index);\r\n  };\r\n\r\n  /**\r\n   * Replace a single element in the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {number[]} index   Zero-based index\r\n   * @param {*} value\r\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be left undefined.\r\n   * @return {DenseMatrix} self\r\n   */\r\n  DenseMatrix.prototype.set = function (index, value, defaultValue) {\r\n    if (!isArray(index)) {\r\n      throw new TypeError('Array expected');\r\n    }\r\n    if (index.length < this._size.length) {\r\n      throw new DimensionError(index.length, this._size.length, '<');\r\n    }\r\n    var i, ii, indexI;\r\n\r\n    // enlarge matrix when needed\r\n    var size = index.map(function (i) {\r\n      return i + 1;\r\n    });\r\n    _fit(this, size, defaultValue);\r\n\r\n    // traverse over the dimensions\r\n    var data = this._data;\r\n    for (i = 0, ii = index.length - 1; i < ii; i++) {\r\n      indexI = index[i];\r\n      validateIndex(indexI, data.length);\r\n      data = data[indexI];\r\n    }\r\n\r\n    // set new value\r\n    indexI = index[index.length - 1];\r\n    validateIndex(indexI, data.length);\r\n    data[indexI] = value;\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Get a submatrix of this matrix\r\n   * @memberof DenseMatrix\r\n   * @param {DenseMatrix} matrix\r\n   * @param {Index} index   Zero-based index\r\n   * @private\r\n   */\r\n  function _get(matrix, index) {\r\n    if (!isIndex(index)) {\r\n      throw new TypeError('Invalid index');\r\n    }\r\n    var isScalar = config.legacySubset ? index.size().every(idx => idx === 1) : index.isScalar();\r\n    if (isScalar) {\r\n      // return a scalar\r\n      return matrix.get(index.min());\r\n    } else {\r\n      // validate dimensions\r\n      var size = index.size();\r\n      if (size.length !== matrix._size.length) {\r\n        throw new DimensionError(size.length, matrix._size.length);\r\n      }\r\n\r\n      // validate if any of the ranges in the index is out of range\r\n      var min = index.min();\r\n      var max = index.max();\r\n      for (var i = 0, ii = matrix._size.length; i < ii; i++) {\r\n        validateIndex(min[i], matrix._size[i]);\r\n        validateIndex(max[i], matrix._size[i]);\r\n      }\r\n\r\n      // retrieve submatrix\r\n      var returnMatrix = new DenseMatrix();\r\n      var submatrix = _getSubmatrix(matrix._data, index);\r\n      returnMatrix._size = submatrix.size;\r\n      returnMatrix._datatype = matrix._datatype;\r\n      returnMatrix._data = submatrix.data;\r\n      return config.legacySubset ? returnMatrix.reshape(index.size()) : returnMatrix;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a submatrix of a multi dimensional matrix.\r\n   * Index is not checked for correct number or length of dimensions.\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @param {Index} index\r\n   * @return {Array} submatrix\r\n   * @private\r\n   */\r\n  function _getSubmatrix(data, index) {\r\n    var maxDepth = index.size().length - 1;\r\n    var size = Array(maxDepth);\r\n    return {\r\n      data: getSubmatrixRecursive(data),\r\n      size: size.filter(x => x !== null)\r\n    };\r\n    function getSubmatrixRecursive(data) {\r\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n      var dims = index.dimension(depth);\r\n      function _mapIndex(dim, callback) {\r\n        // applies a callback for when the index is a Number or a Matrix\r\n        if (isNumber(dim)) return callback(dim);else return dim.map(callback).valueOf();\r\n      }\r\n      if (isNumber(dims)) {\r\n        size[depth] = null;\r\n      } else {\r\n        size[depth] = dims.size()[0];\r\n      }\r\n      if (depth < maxDepth) {\r\n        return _mapIndex(dims, dimIndex => {\r\n          validateIndex(dimIndex, data.length);\r\n          return getSubmatrixRecursive(data[dimIndex], depth + 1);\r\n        });\r\n      } else {\r\n        return _mapIndex(dims, dimIndex => {\r\n          validateIndex(dimIndex, data.length);\r\n          return data[dimIndex];\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Replace a submatrix in this matrix\r\n   * Indexes are zero-based.\r\n   * @memberof DenseMatrix\r\n   * @param {DenseMatrix} matrix\r\n   * @param {Index} index\r\n   * @param {DenseMatrix | Array | *} submatrix\r\n   * @param {*} defaultValue          Default value, filled in on new entries when\r\n   *                                  the matrix is resized.\r\n   * @return {DenseMatrix} matrix\r\n   * @private\r\n   */\r\n  function _set(matrix, index, submatrix, defaultValue) {\r\n    if (!index || index.isIndex !== true) {\r\n      throw new TypeError('Invalid index');\r\n    }\r\n\r\n    // get index size and check whether the index contains a single value\r\n    var iSize = index.size();\r\n    var isScalar = index.isScalar();\r\n\r\n    // calculate the size of the submatrix, and convert it into an Array if needed\r\n    var submatrixSize;\r\n    if (isMatrix(submatrix)) {\r\n      submatrixSize = submatrix.size();\r\n      submatrix = submatrix.valueOf();\r\n    } else {\r\n      submatrixSize = arraySize(submatrix);\r\n    }\r\n    if (isScalar) {\r\n      // set a scalar\r\n\r\n      // check whether submatrix is a scalar\r\n      if (submatrixSize.length !== 0) {\r\n        throw new TypeError('Scalar expected');\r\n      }\r\n      matrix.set(index.min(), submatrix, defaultValue);\r\n    } else {\r\n      // set a submatrix\r\n\r\n      // broadcast submatrix\r\n      if (!deepStrictEqual(submatrixSize, iSize)) {\r\n        if (submatrixSize.length === 0) {\r\n          submatrix = broadcastTo([submatrix], iSize);\r\n        } else {\r\n          try {\r\n            submatrix = broadcastTo(submatrix, iSize);\r\n          } catch (error) {}\r\n        }\r\n        submatrixSize = arraySize(submatrix);\r\n      }\r\n\r\n      // validate dimensions\r\n      if (iSize.length < matrix._size.length) {\r\n        throw new DimensionError(iSize.length, matrix._size.length, '<');\r\n      }\r\n      if (submatrixSize.length < iSize.length) {\r\n        // calculate number of missing outer dimensions\r\n        var i = 0;\r\n        var outer = 0;\r\n        while (iSize[i] === 1 && submatrixSize[i] === 1) {\r\n          i++;\r\n        }\r\n        while (iSize[i] === 1) {\r\n          outer++;\r\n          i++;\r\n        }\r\n\r\n        // unsqueeze both outer and inner dimensions\r\n        submatrix = unsqueeze(submatrix, iSize.length, outer, submatrixSize);\r\n      }\r\n\r\n      // check whether the size of the submatrix matches the index size\r\n      if (!deepStrictEqual(iSize, submatrixSize)) {\r\n        throw new DimensionError(iSize, submatrixSize, '>');\r\n      }\r\n\r\n      // enlarge matrix when needed\r\n      var size = index.max().map(function (i) {\r\n        return i + 1;\r\n      });\r\n      _fit(matrix, size, defaultValue);\r\n\r\n      // insert the sub matrix\r\n      _setSubmatrix(matrix._data, index, submatrix);\r\n    }\r\n    return matrix;\r\n  }\r\n\r\n  /**\r\n   * Replace a submatrix of a multi dimensional matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {Array} data\r\n   * @param {Index} index\r\n   * @param {Array} submatrix\r\n   * @private\r\n   */\r\n  function _setSubmatrix(data, index, submatrix) {\r\n    var maxDepth = index.size().length - 1;\r\n    setSubmatrixRecursive(data, submatrix);\r\n    function setSubmatrixRecursive(data, submatrix) {\r\n      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\r\n      var range = index.dimension(depth);\r\n      var recursiveCallback = (rangeIndex, i) => {\r\n        validateIndex(rangeIndex, data.length);\r\n        setSubmatrixRecursive(data[rangeIndex], submatrix[i[0]], depth + 1);\r\n      };\r\n      var finalCallback = (rangeIndex, i) => {\r\n        validateIndex(rangeIndex, data.length);\r\n        data[rangeIndex] = submatrix[i[0]];\r\n      };\r\n      if (depth < maxDepth) {\r\n        if (isNumber(range)) recursiveCallback(range, [0]);else range.forEach(recursiveCallback);\r\n      } else {\r\n        if (isNumber(range)) finalCallback(range, [0]);else range.forEach(finalCallback);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resize the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (resize in place).\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number[] || Matrix} size The new size the matrix should have.\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\r\n   *                                  If not provided, the matrix elements will\r\n   *                                  be filled with zeros.\r\n   * @param {boolean} [copy]          Return a resized copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The resized matrix\r\n   */\r\n  DenseMatrix.prototype.resize = function (size, defaultValue, copy) {\r\n    // validate arguments\r\n    if (!isCollection(size)) {\r\n      throw new TypeError('Array or Matrix expected');\r\n    }\r\n\r\n    // SparseMatrix input is always 2d, flatten this into 1d if it's indeed a vector\r\n    var sizeArray = size.valueOf().map(value => {\r\n      return Array.isArray(value) && value.length === 1 ? value[0] : value;\r\n    });\r\n\r\n    // matrix to resize\r\n    var m = copy ? this.clone() : this;\r\n    // resize matrix\r\n    return _resize(m, sizeArray, defaultValue);\r\n  };\r\n  function _resize(matrix, size, defaultValue) {\r\n    // check size\r\n    if (size.length === 0) {\r\n      // first value in matrix\r\n      var v = matrix._data;\r\n      // go deep\r\n      while (isArray(v)) {\r\n        v = v[0];\r\n      }\r\n      return v;\r\n    }\r\n    // resize matrix\r\n    matrix._size = size.slice(0); // copy the array\r\n    matrix._data = resize(matrix._data, matrix._size, defaultValue);\r\n    // return matrix\r\n    return matrix;\r\n  }\r\n\r\n  /**\r\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\r\n   *\r\n   * NOTE: This might be better suited to copy by default, instead of modifying\r\n   *       in place. For now, it operates in place to remain consistent with\r\n   *       resize().\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number[]} size           The new size the matrix should have.\r\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The reshaped matrix\r\n   */\r\n  DenseMatrix.prototype.reshape = function (size, copy) {\r\n    var m = copy ? this.clone() : this;\r\n    m._data = reshape(m._data, size);\r\n    var currentLength = m._size.reduce((length, size) => length * size);\r\n    m._size = processSizesWildcard(size, currentLength);\r\n    return m;\r\n  };\r\n\r\n  /**\r\n   * Enlarge the matrix when it is smaller than given size.\r\n   * If the matrix is larger or equal sized, nothing is done.\r\n   * @memberof DenseMatrix\r\n   * @param {DenseMatrix} matrix           The matrix to be resized\r\n   * @param {number[]} size\r\n   * @param {*} defaultValue          Default value, filled in on new entries.\r\n   * @private\r\n   */\r\n  function _fit(matrix, size, defaultValue) {\r\n    var\r\n    // copy the array\r\n    newSize = matrix._size.slice(0);\r\n    var changed = false;\r\n\r\n    // add dimensions when needed\r\n    while (newSize.length < size.length) {\r\n      newSize.push(0);\r\n      changed = true;\r\n    }\r\n\r\n    // enlarge size when needed\r\n    for (var i = 0, ii = size.length; i < ii; i++) {\r\n      if (size[i] > newSize[i]) {\r\n        newSize[i] = size[i];\r\n        changed = true;\r\n      }\r\n    }\r\n    if (changed) {\r\n      // resize only when size is changed\r\n      _resize(matrix, newSize, defaultValue);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a clone of the matrix\r\n   * @memberof DenseMatrix\r\n   * @return {DenseMatrix} clone\r\n   */\r\n  DenseMatrix.prototype.clone = function () {\r\n    var m = new DenseMatrix({\r\n      data: clone(this._data),\r\n      size: clone(this._size),\r\n      datatype: this._datatype\r\n    });\r\n    return m;\r\n  };\r\n\r\n  /**\r\n   * Retrieve the size of the matrix.\r\n   * @memberof DenseMatrix\r\n   * @returns {number[]} size\r\n   */\r\n  DenseMatrix.prototype.size = function () {\r\n    return this._size.slice(0); // return a clone of _size\r\n  };\r\n\r\n  /**\r\n   * Create a new matrix with the results of the callback function executed on\r\n   * each entry of the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   * @param {boolean} skipZeros   If true, the callback function is invoked only for non-zero entries\r\n   * @param {boolean} isUnary     If true, the callback function is invoked with one parameter\r\n   *\r\n   * @return {DenseMatrix} matrix\r\n   */\r\n  DenseMatrix.prototype.map = function (callback) {\r\n    var skipZeros = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n    var isUnary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n    var me = this;\r\n    var maxDepth = me._size.length - 1;\r\n    if (maxDepth < 0) return me.clone();\r\n    var fastCallback = optimizeCallback(callback, me, 'map', isUnary);\r\n    var fastCallbackFn = fastCallback.fn;\r\n    var result = me.create(undefined, me._datatype);\r\n    result._size = me._size;\r\n    if (isUnary || fastCallback.isUnary) {\r\n      result._data = iterateUnary(me._data);\r\n      return result;\r\n    }\r\n    if (maxDepth === 0) {\r\n      var inputData = me.valueOf();\r\n      var data = Array(inputData.length);\r\n      for (var i = 0; i < inputData.length; i++) {\r\n        data[i] = fastCallbackFn(inputData[i], [i], me);\r\n      }\r\n      result._data = data;\r\n      return result;\r\n    }\r\n    var index = [];\r\n    result._data = iterate(me._data);\r\n    return result;\r\n    function iterate(data) {\r\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n      var result = Array(data.length);\r\n      if (depth < maxDepth) {\r\n        for (var _i = 0; _i < data.length; _i++) {\r\n          index[depth] = _i;\r\n          result[_i] = iterate(data[_i], depth + 1);\r\n        }\r\n      } else {\r\n        for (var _i2 = 0; _i2 < data.length; _i2++) {\r\n          index[depth] = _i2;\r\n          result[_i2] = fastCallbackFn(data[_i2], index.slice(), me);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n    function iterateUnary(data) {\r\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n      var result = Array(data.length);\r\n      if (depth < maxDepth) {\r\n        for (var _i3 = 0; _i3 < data.length; _i3++) {\r\n          result[_i3] = iterateUnary(data[_i3], depth + 1);\r\n        }\r\n      } else {\r\n        for (var _i4 = 0; _i4 < data.length; _i4++) {\r\n          result[_i4] = fastCallbackFn(data[_i4]);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Execute a callback function on each entry of the matrix.\r\n   * @memberof DenseMatrix\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   * @param {boolean} skipZeros   If true, the callback function is invoked only for non-zero entries\r\n   * @param {boolean} isUnary     If true, the callback function is invoked with one parameter\r\n   */\r\n  DenseMatrix.prototype.forEach = function (callback) {\r\n    var skipZeros = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n    var isUnary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n    var me = this;\r\n    var maxDepth = me._size.length - 1;\r\n    if (maxDepth < 0) return;\r\n    var fastCallback = optimizeCallback(callback, me, 'map', isUnary);\r\n    var fastCallbackFn = fastCallback.fn;\r\n    if (isUnary || fastCallback.isUnary) {\r\n      iterateUnary(me._data);\r\n      return;\r\n    }\r\n    if (maxDepth === 0) {\r\n      for (var i = 0; i < me._data.length; i++) {\r\n        fastCallbackFn(me._data[i], [i], me);\r\n      }\r\n      return;\r\n    }\r\n    var index = [];\r\n    iterate(me._data);\r\n    function iterate(data) {\r\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n      if (depth < maxDepth) {\r\n        for (var _i5 = 0; _i5 < data.length; _i5++) {\r\n          index[depth] = _i5;\r\n          iterate(data[_i5], depth + 1);\r\n        }\r\n      } else {\r\n        for (var _i6 = 0; _i6 < data.length; _i6++) {\r\n          index[depth] = _i6;\r\n          fastCallbackFn(data[_i6], index.slice(), me);\r\n        }\r\n      }\r\n    }\r\n    function iterateUnary(data) {\r\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n      if (depth < maxDepth) {\r\n        for (var _i7 = 0; _i7 < data.length; _i7++) {\r\n          iterateUnary(data[_i7], depth + 1);\r\n        }\r\n      } else {\r\n        for (var _i8 = 0; _i8 < data.length; _i8++) {\r\n          fastCallbackFn(data[_i8]);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Iterate over the matrix elements\r\n   * @return {Iterable<{ value, index: number[] }>}\r\n   */\r\n  DenseMatrix.prototype[Symbol.iterator] = function* () {\r\n    var maxDepth = this._size.length - 1;\r\n    if (maxDepth < 0) {\r\n      return;\r\n    }\r\n    if (maxDepth === 0) {\r\n      for (var i = 0; i < this._data.length; i++) {\r\n        yield {\r\n          value: this._data[i],\r\n          index: [i]\r\n        };\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Multi-dimensional matrix: iterate over all elements\r\n    var index = Array(maxDepth + 1).fill(0);\r\n    var totalElements = this._size.reduce((a, b) => a * b, 1);\r\n    for (var count = 0; count < totalElements; count++) {\r\n      // Traverse to the current element using indices\r\n      var current = this._data;\r\n      for (var d = 0; d < maxDepth; d++) {\r\n        current = current[index[d]];\r\n      }\r\n      yield {\r\n        value: current[index[maxDepth]],\r\n        index: index.slice()\r\n      };\r\n\r\n      // Increment indices for next element\r\n      for (var _d = maxDepth; _d >= 0; _d--) {\r\n        index[_d]++;\r\n        if (index[_d] < this._size[_d]) break;\r\n        index[_d] = 0;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns an array containing the rows of a 2D matrix\r\n   * @returns {Array<Matrix>}\r\n   */\r\n  DenseMatrix.prototype.rows = function () {\r\n    var result = [];\r\n    var s = this.size();\r\n    if (s.length !== 2) {\r\n      throw new TypeError('Rows can only be returned for a 2D matrix.');\r\n    }\r\n    var data = this._data;\r\n    for (var row of data) {\r\n      result.push(new DenseMatrix([row], this._datatype));\r\n    }\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Returns an array containing the columns of a 2D matrix\r\n   * @returns {Array<Matrix>}\r\n   */\r\n  DenseMatrix.prototype.columns = function () {\r\n    var _this = this;\r\n    var result = [];\r\n    var s = this.size();\r\n    if (s.length !== 2) {\r\n      throw new TypeError('Rows can only be returned for a 2D matrix.');\r\n    }\r\n    var data = this._data;\r\n    var _loop = function _loop(i) {\r\n      var col = data.map(row => [row[i]]);\r\n      result.push(new DenseMatrix(col, _this._datatype));\r\n    };\r\n    for (var i = 0; i < s[1]; i++) {\r\n      _loop(i);\r\n    }\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Create an Array with a copy of the data of the DenseMatrix\r\n   * @memberof DenseMatrix\r\n   * @returns {Array} array\r\n   */\r\n  DenseMatrix.prototype.toArray = function () {\r\n    return clone(this._data);\r\n  };\r\n\r\n  /**\r\n   * Get the primitive value of the DenseMatrix: a multidimensional array\r\n   * @memberof DenseMatrix\r\n   * @returns {Array} array\r\n   */\r\n  DenseMatrix.prototype.valueOf = function () {\r\n    return this._data;\r\n  };\r\n\r\n  /**\r\n   * Get a string representation of the matrix, with optional formatting options.\r\n   * @memberof DenseMatrix\r\n   * @param {Object | number | Function} [options]  Formatting options. See\r\n   *                                                lib/utils/number:format for a\r\n   *                                                description of the available\r\n   *                                                options.\r\n   * @returns {string} str\r\n   */\r\n  DenseMatrix.prototype.format = function (options) {\r\n    return format(this._data, options);\r\n  };\r\n\r\n  /**\r\n   * Get a string representation of the matrix\r\n   * @memberof DenseMatrix\r\n   * @returns {string} str\r\n   */\r\n  DenseMatrix.prototype.toString = function () {\r\n    return format(this._data);\r\n  };\r\n\r\n  /**\r\n   * Get a JSON representation of the matrix\r\n   * @memberof DenseMatrix\r\n   * @returns {Object}\r\n   */\r\n  DenseMatrix.prototype.toJSON = function () {\r\n    return {\r\n      mathjs: 'DenseMatrix',\r\n      data: this._data,\r\n      size: this._size,\r\n      datatype: this._datatype\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Get the kth Matrix diagonal.\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number | BigNumber} [k=0]     The kth diagonal where the vector will retrieved.\r\n   *\r\n   * @returns {Matrix}                     The matrix with the diagonal values.\r\n   */\r\n  DenseMatrix.prototype.diagonal = function (k) {\r\n    // validate k if any\r\n    if (k) {\r\n      // convert BigNumber to a number\r\n      if (isBigNumber(k)) {\r\n        k = k.toNumber();\r\n      }\r\n      // is must be an integer\r\n      if (!isNumber(k) || !isInteger(k)) {\r\n        throw new TypeError('The parameter k must be an integer number');\r\n      }\r\n    } else {\r\n      // default value\r\n      k = 0;\r\n    }\r\n    var kSuper = k > 0 ? k : 0;\r\n    var kSub = k < 0 ? -k : 0;\r\n\r\n    // rows & columns\r\n    var rows = this._size[0];\r\n    var columns = this._size[1];\r\n\r\n    // number diagonal values\r\n    var n = Math.min(rows - kSub, columns - kSuper);\r\n\r\n    // x is a matrix get diagonal from matrix\r\n    var data = [];\r\n\r\n    // loop rows\r\n    for (var i = 0; i < n; i++) {\r\n      data[i] = this._data[i + kSub][i + kSuper];\r\n    }\r\n\r\n    // create DenseMatrix\r\n    return new DenseMatrix({\r\n      data,\r\n      size: [n],\r\n      datatype: this._datatype\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Create a diagonal matrix.\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {Array} size                     The matrix size.\r\n   * @param {number | Matrix | Array } value The values for the diagonal.\r\n   * @param {number | BigNumber} [k=0]       The kth diagonal where the vector will be filled in.\r\n   * @param {number} [defaultValue]          The default value for non-diagonal\r\n   * @param {string} [datatype]              The datatype for the diagonal\r\n   *\r\n   * @returns {DenseMatrix}\r\n   */\r\n  DenseMatrix.diagonal = function (size, value, k, defaultValue) {\r\n    if (!isArray(size)) {\r\n      throw new TypeError('Array expected, size parameter');\r\n    }\r\n    if (size.length !== 2) {\r\n      throw new Error('Only two dimensions matrix are supported');\r\n    }\r\n\r\n    // map size & validate\r\n    size = size.map(function (s) {\r\n      // check it is a big number\r\n      if (isBigNumber(s)) {\r\n        // convert it\r\n        s = s.toNumber();\r\n      }\r\n      // validate arguments\r\n      if (!isNumber(s) || !isInteger(s) || s < 1) {\r\n        throw new Error('Size values must be positive integers');\r\n      }\r\n      return s;\r\n    });\r\n\r\n    // validate k if any\r\n    if (k) {\r\n      // convert BigNumber to a number\r\n      if (isBigNumber(k)) {\r\n        k = k.toNumber();\r\n      }\r\n      // is must be an integer\r\n      if (!isNumber(k) || !isInteger(k)) {\r\n        throw new TypeError('The parameter k must be an integer number');\r\n      }\r\n    } else {\r\n      // default value\r\n      k = 0;\r\n    }\r\n    var kSuper = k > 0 ? k : 0;\r\n    var kSub = k < 0 ? -k : 0;\r\n\r\n    // rows and columns\r\n    var rows = size[0];\r\n    var columns = size[1];\r\n\r\n    // number of non-zero items\r\n    var n = Math.min(rows - kSub, columns - kSuper);\r\n\r\n    // value extraction function\r\n    var _value;\r\n\r\n    // check value\r\n    if (isArray(value)) {\r\n      // validate array\r\n      if (value.length !== n) {\r\n        // number of values in array must be n\r\n        throw new Error('Invalid value array length');\r\n      }\r\n      // define function\r\n      _value = function _value(i) {\r\n        // return value @ i\r\n        return value[i];\r\n      };\r\n    } else if (isMatrix(value)) {\r\n      // matrix size\r\n      var ms = value.size();\r\n      // validate matrix\r\n      if (ms.length !== 1 || ms[0] !== n) {\r\n        // number of values in array must be n\r\n        throw new Error('Invalid matrix length');\r\n      }\r\n      // define function\r\n      _value = function _value(i) {\r\n        // return value @ i\r\n        return value.get([i]);\r\n      };\r\n    } else {\r\n      // define function\r\n      _value = function _value() {\r\n        // return value\r\n        return value;\r\n      };\r\n    }\r\n\r\n    // discover default value if needed\r\n    if (!defaultValue) {\r\n      // check first value in array\r\n      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) // trick to create a BigNumber with value zero\r\n      : 0;\r\n    }\r\n\r\n    // empty array\r\n    var data = [];\r\n\r\n    // check we need to resize array\r\n    if (size.length > 0) {\r\n      // resize array\r\n      data = resize(data, size, defaultValue);\r\n      // fill diagonal\r\n      for (var d = 0; d < n; d++) {\r\n        data[d + kSub][d + kSuper] = _value(d);\r\n      }\r\n    }\r\n\r\n    // create DenseMatrix\r\n    return new DenseMatrix({\r\n      data,\r\n      size: [rows, columns]\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Generate a matrix from a JSON object\r\n   * @memberof DenseMatrix\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"DenseMatrix\", data: [], size: []}`,\r\n   *                       where mathjs is optional\r\n   * @returns {DenseMatrix}\r\n   */\r\n  DenseMatrix.fromJSON = function (json) {\r\n    return new DenseMatrix(json);\r\n  };\r\n\r\n  /**\r\n   * Swap rows i and j in Matrix.\r\n   *\r\n   * @memberof DenseMatrix\r\n   * @param {number} i       Matrix row index 1\r\n   * @param {number} j       Matrix row index 2\r\n   *\r\n   * @return {Matrix}        The matrix reference\r\n   */\r\n  DenseMatrix.prototype.swapRows = function (i, j) {\r\n    // check index\r\n    if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {\r\n      throw new Error('Row index must be positive integers');\r\n    }\r\n    // check dimensions\r\n    if (this._size.length !== 2) {\r\n      throw new Error('Only two dimensional matrix is supported');\r\n    }\r\n    // validate index\r\n    validateIndex(i, this._size[0]);\r\n    validateIndex(j, this._size[0]);\r\n\r\n    // swap rows\r\n    DenseMatrix._swapRows(i, j, this._data);\r\n    // return current instance\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Swap rows i and j in Dense Matrix data structure.\r\n   *\r\n   * @param {number} i       Matrix row index 1\r\n   * @param {number} j       Matrix row index 2\r\n   * @param {Array} data     Matrix data\r\n   */\r\n  DenseMatrix._swapRows = function (i, j, data) {\r\n    // swap values i <-> j\r\n    var vi = data[i];\r\n    data[i] = data[j];\r\n    data[j] = vi;\r\n  };\r\n\r\n  /**\r\n   * Preprocess data, which can be an Array or DenseMatrix with nested Arrays and\r\n   * Matrices. Clones all (nested) Arrays, and replaces all nested Matrices with Arrays\r\n   * @memberof DenseMatrix\r\n   * @param {Array | Matrix} data\r\n   * @return {Array} data\r\n   */\r\n  function preprocess(data) {\r\n    if (isMatrix(data)) {\r\n      return preprocess(data.valueOf());\r\n    }\r\n    if (isArray(data)) {\r\n      return data.map(preprocess);\r\n    }\r\n    return data;\r\n  }\r\n  return DenseMatrix;\r\n}, {\r\n  isClass: true\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}