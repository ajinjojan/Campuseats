{"ast":null,"code":"import { createNullish } from '../../function/logical/nullish.js';\nimport { factory } from '../../utils/factory.js';\nimport { isCollection } from '../../utils/is.js';\nvar name = 'nullish';\nvar dependencies = ['typed', 'matrix', 'size', 'flatten', 'deepEqual'];\nexport var createNullishTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    size,\n    flatten,\n    deepEqual\n  } = _ref;\n  var nullish = createNullish({\n    typed,\n    matrix,\n    size,\n    flatten,\n    deepEqual\n  });\n  function nullishTransform(args, math, scope) {\n    var left = args[0].compile().evaluate(scope);\n\n    // If left is not a collection and not nullish, short-circuit and return it\n    if (!isCollection(left) && left != null && left !== undefined) {\n      return left;\n    }\n\n    // Otherwise evaluate right and apply full nullish semantics (incl. element-wise)\n    var right = args[1].compile().evaluate(scope);\n    return nullish(left, right);\n  }\n  nullishTransform.rawArgs = true;\n  return nullishTransform;\n}, {\n  isTransformFunction: true\n});","map":{"version":3,"names":["createNullish","factory","isCollection","name","dependencies","createNullishTransform","_ref","typed","matrix","size","flatten","deepEqual","nullish","nullishTransform","args","math","scope","left","compile","evaluate","undefined","right","rawArgs","isTransformFunction"],"sources":["C:/Users/dudet/Documents/gitexp/CampusEats/node_modules/mathjs/lib/esm/expression/transform/nullish.transform.js"],"sourcesContent":["import { createNullish } from '../../function/logical/nullish.js';\nimport { factory } from '../../utils/factory.js';\nimport { isCollection } from '../../utils/is.js';\nvar name = 'nullish';\nvar dependencies = ['typed', 'matrix', 'size', 'flatten', 'deepEqual'];\nexport var createNullishTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    size,\n    flatten,\n    deepEqual\n  } = _ref;\n  var nullish = createNullish({\n    typed,\n    matrix,\n    size,\n    flatten,\n    deepEqual\n  });\n  function nullishTransform(args, math, scope) {\n    var left = args[0].compile().evaluate(scope);\n\n    // If left is not a collection and not nullish, short-circuit and return it\n    if (!isCollection(left) && left != null && left !== undefined) {\n      return left;\n    }\n\n    // Otherwise evaluate right and apply full nullish semantics (incl. element-wise)\n    var right = args[1].compile().evaluate(scope);\n    return nullish(left, right);\n  }\n  nullishTransform.rawArgs = true;\n  return nullishTransform;\n}, {\n  isTransformFunction: true\n});"],"mappings":"AAAA,SAASA,aAAa,QAAQ,mCAAmC;AACjE,SAASC,OAAO,QAAQ,wBAAwB;AAChD,SAASC,YAAY,QAAQ,mBAAmB;AAChD,IAAIC,IAAI,GAAG,SAAS;AACpB,IAAIC,YAAY,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,WAAW,CAAC;AACtE,OAAO,IAAIC,sBAAsB,GAAG,eAAeJ,OAAO,CAACE,IAAI,EAAEC,YAAY,EAAEE,IAAI,IAAI;EACrF,IAAI;IACFC,KAAK;IACLC,MAAM;IACNC,IAAI;IACJC,OAAO;IACPC;EACF,CAAC,GAAGL,IAAI;EACR,IAAIM,OAAO,GAAGZ,aAAa,CAAC;IAC1BO,KAAK;IACLC,MAAM;IACNC,IAAI;IACJC,OAAO;IACPC;EACF,CAAC,CAAC;EACF,SAASE,gBAAgBA,CAACC,IAAI,EAAEC,IAAI,EAAEC,KAAK,EAAE;IAC3C,IAAIC,IAAI,GAAGH,IAAI,CAAC,CAAC,CAAC,CAACI,OAAO,CAAC,CAAC,CAACC,QAAQ,CAACH,KAAK,CAAC;;IAE5C;IACA,IAAI,CAACd,YAAY,CAACe,IAAI,CAAC,IAAIA,IAAI,IAAI,IAAI,IAAIA,IAAI,KAAKG,SAAS,EAAE;MAC7D,OAAOH,IAAI;IACb;;IAEA;IACA,IAAII,KAAK,GAAGP,IAAI,CAAC,CAAC,CAAC,CAACI,OAAO,CAAC,CAAC,CAACC,QAAQ,CAACH,KAAK,CAAC;IAC7C,OAAOJ,OAAO,CAACK,IAAI,EAAEI,KAAK,CAAC;EAC7B;EACAR,gBAAgB,CAACS,OAAO,GAAG,IAAI;EAC/B,OAAOT,gBAAgB;AACzB,CAAC,EAAE;EACDU,mBAAmB,EAAE;AACvB,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}