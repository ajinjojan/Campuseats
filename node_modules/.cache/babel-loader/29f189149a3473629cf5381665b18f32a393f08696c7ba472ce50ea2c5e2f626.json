{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport { factory } from '../utils/factory.js';\nimport { isAccessorNode, isConstantNode, isFunctionNode, isOperatorNode, isSymbolNode, rule2Node } from '../utils/is.js';\nimport { deepMap } from '../utils/collection.js';\nimport { safeNumberType } from '../utils/number.js';\nimport { hasOwnProperty } from '../utils/object.js';\nvar name = 'parse';\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\nexport var createParse = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    numeric,\n    config,\n    AccessorNode,\n    ArrayNode,\n    AssignmentNode,\n    BlockNode,\n    ConditionalNode,\n    ConstantNode,\n    FunctionAssignmentNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    RangeNode,\n    RelationalNode,\n    SymbolNode\n  } = _ref;\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.evaluate() or transformed into a functional object via node.compile().\n   *\n   * Note the evaluating arbitrary expressions may involve security risks,\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\n   *\n   * Syntax:\n   *\n   *     math.parse(expr)\n   *     math.parse(expr, options)\n   *     math.parse([expr1, expr2, expr3, ...])\n   *     math.parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\n   *     node1.compile().evaluate() // 5\n   *\n   *     let scope = {a:3, b:4}\n   *     const node2 = math.parse('a * b')\n   *     node2.evaluate(scope) // 12\n   *     const code2 = node2.compile()\n   *     code2.evaluate(scope) // 12\n   *     scope.a = 5\n   *     code2.evaluate(scope) // 20\n   *\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].compile().evaluate() // 12\n   *\n   * See also:\n   *\n   *     evaluate, compile\n   *\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n  var parse = typed(name, {\n    string: function string(expression) {\n      return parseStart(expression, {});\n    },\n    'Array | Matrix': function Array__Matrix(expressions) {\n      return parseMultiple(expressions, {});\n    },\n    'string, Object': function string_Object(expression, options) {\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\n      return parseStart(expression, extraNodes);\n    },\n    'Array | Matrix, Object': parseMultiple\n  });\n  function parseMultiple(expressions) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var extraNodes = options.nodes !== undefined ? options.nodes : {};\n\n    // parse an array or matrix with expressions\n    return deepMap(expressions, function (elem) {\n      if (typeof elem !== 'string') throw new TypeError('String expected');\n      return parseStart(elem, extraNodes);\n    });\n  }\n\n  // token types enumeration\n  var TOKENTYPE = {\n    NULL: 0,\n    DELIMITER: 1,\n    NUMBER: 2,\n    SYMBOL: 3,\n    UNKNOWN: 4\n  };\n\n  // map with all delimiters\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\"': true,\n    '\\'': true,\n    ';': true,\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '=': true,\n    ':': true,\n    '?': true,\n    '?.': true,\n    '??': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  };\n\n  // map with all named delimiters\n  var NAMED_DELIMITERS = {\n    mod: true,\n    to: true,\n    in: true,\n    and: true,\n    xor: true,\n    or: true,\n    not: true\n  };\n  var CONSTANTS = {\n    true: true,\n    false: false,\n    null: null,\n    undefined\n  };\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\n  var ESCAPE_CHARACTERS = {\n    '\"': '\"',\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '/': '/',\n    b: '\\b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t'\n    // note that \\u is handled separately in parseStringToken()\n  };\n  function initialState() {\n    return {\n      extraNodes: {},\n      // current extra nodes, must be careful not to mutate\n      expression: '',\n      // current expression\n      comment: '',\n      // last parsed comment\n      index: 0,\n      // current index in expr\n      token: '',\n      // current token\n      tokenType: TOKENTYPE.NULL,\n      // type of the token\n      nestingLevel: 0,\n      // level of nesting inside parameters, used to ignore newline characters\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\n    };\n  }\n\n  /**\n   * View upto `length` characters of the expression starting at the current character.\n   *\n   * @param {Object} state\n   * @param {number} [length=1] Number of characters to view\n   * @returns {string}\n   * @private\n   */\n  function currentString(state, length) {\n    return state.expression.substr(state.index, length);\n  }\n\n  /**\n   * View the current character. Returns '' if end of expression is reached.\n   *\n   * @param {Object} state\n   * @returns {string}\n   * @private\n   */\n  function currentCharacter(state) {\n    return currentString(state, 1);\n  }\n\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n  function next(state) {\n    state.index++;\n  }\n\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function prevCharacter(state) {\n    return state.expression.charAt(state.index - 1);\n  }\n\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function nextCharacter(state) {\n    return state.expression.charAt(state.index + 1);\n  }\n\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and tokenType\n   * @private\n   */\n  function getToken(state) {\n    state.tokenType = TOKENTYPE.NULL;\n    state.token = '';\n    state.comment = '';\n\n    // skip over ignored characters:\n    while (true) {\n      // comments:\n      if (currentCharacter(state) === '#') {\n        while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\n          state.comment += currentCharacter(state);\n          next(state);\n        }\n      }\n      // whitespace: space, tab, and newline when inside parameters\n      if (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\n        next(state);\n      } else {\n        break;\n      }\n    }\n\n    // check for end of expression\n    if (currentCharacter(state) === '') {\n      // token is still empty\n      state.tokenType = TOKENTYPE.DELIMITER;\n      return;\n    }\n\n    // check for new line character\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = currentCharacter(state);\n      next(state);\n      return;\n    }\n    var c1 = currentCharacter(state);\n    var c2 = currentString(state, 2);\n    var c3 = currentString(state, 3);\n    if (c3.length === 3 && DELIMITERS[c3]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c3;\n      next(state);\n      next(state);\n      next(state);\n      return;\n    }\n\n    // check for delimiters consisting of 2 characters\n    // Special case: the check for '?.' is to prevent a case like 'a?.3:.7' from being interpreted as optional chaining\n    // TODO: refactor the tokenization into some better way to deal with cases like 'a?.3:.7', see https://github.com/josdejong/mathjs/pull/3584\n    if (c2.length === 2 && DELIMITERS[c2] && (c2 !== '?.' || !parse.isDigit(state.expression.charAt(state.index + 2)))) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c2;\n      next(state);\n      next(state);\n      return;\n    }\n\n    // check for delimiters consisting of 1 character\n    if (DELIMITERS[c1]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c1;\n      next(state);\n      return;\n    }\n\n    // check for a number\n    if (parse.isDigitDot(c1)) {\n      state.tokenType = TOKENTYPE.NUMBER;\n\n      // check for binary, octal, or hex\n      var _c = currentString(state, 2);\n      if (_c === '0b' || _c === '0o' || _c === '0x') {\n        state.token += currentCharacter(state);\n        next(state);\n        state.token += currentCharacter(state);\n        next(state);\n        while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n        if (currentCharacter(state) === '.') {\n          // this number has a radix point\n          state.token += '.';\n          next(state);\n          // get the digits after the radix\n          while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        } else if (currentCharacter(state) === 'i') {\n          // this number has a word size suffix\n          state.token += 'i';\n          next(state);\n          // get the word size\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        }\n        return;\n      }\n\n      // get number, can have a single dot\n      if (currentCharacter(state) === '.') {\n        state.token += currentCharacter(state);\n        next(state);\n        if (!parse.isDigit(currentCharacter(state))) {\n          // this is no number, it is just a dot (can be dot notation)\n          state.tokenType = TOKENTYPE.DELIMITER;\n          return;\n        }\n      } else {\n        while (parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n      }\n      while (parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n      // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\n          state.token += currentCharacter(state);\n          next(state);\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n          // Scientific notation MUST be followed by an exponent\n          if (!parse.isDigit(currentCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n        } else if (parse.isDecimalMark(nextCharacter(state), state.expression.charAt(state.index + 2))) {\n          next(state);\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n        }\n      }\n      return;\n    }\n\n    // check for variables, functions, named operators\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {\n        state.tokenType = TOKENTYPE.DELIMITER;\n      } else {\n        state.tokenType = TOKENTYPE.SYMBOL;\n      }\n      return;\n    }\n\n    // something unknown is found, wrong characters -> a syntax error\n    state.tokenType = TOKENTYPE.UNKNOWN;\n    while (currentCharacter(state) !== '') {\n      state.token += currentCharacter(state);\n      next(state);\n    }\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\n  }\n\n  /**\n   * Get next token and skip newline tokens\n   */\n  function getTokenSkipNewline(state) {\n    do {\n      getToken(state);\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\n  }\n\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams(state) is called\n   */\n  function openParams(state) {\n    state.nestingLevel++;\n  }\n\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n  function closeParams(state) {\n    state.nestingLevel--;\n  }\n\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\n  };\n\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * https://unicode-table.com/en/\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c === ' ' || c === '\\t' || c === '\\u00A0' || c === '\\n' && nestingLevel > 0;\n  };\n\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n  parse.isDigitDot = function isDigitDot(c) {\n    return c >= '0' && c <= '9' || c === '.';\n  };\n\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n  parse.isDigit = function isDigit(c) {\n    return c >= '0' && c <= '9';\n  };\n\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n  function parseStart(expression, extraNodes) {\n    var state = initialState();\n    _extends(state, {\n      expression,\n      extraNodes\n    });\n    getToken(state);\n    var node = parseBlock(state);\n\n    // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and tokenType DELIMITER\n    if (state.token !== '') {\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\n        throw createError(state, 'Unexpected operator ' + state.token);\n      } else {\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n  function parseBlock(state) {\n    var node;\n    var blocks = [];\n    var visible;\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\n      node = parseAssignment(state);\n      if (state.comment) {\n        node.comment = state.comment;\n      }\n    }\n\n    // TODO: simplify this loop\n    while (state.token === '\\n' || state.token === ';') {\n      // eslint-disable-line no-unmodified-loop-condition\n      if (blocks.length === 0 && node) {\n        visible = state.token !== ';';\n        blocks.push({\n          node,\n          visible\n        });\n      }\n      getToken(state);\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\n        node = parseAssignment(state);\n        if (state.comment) {\n          node.comment = state.comment;\n        }\n        visible = state.token !== ';';\n        blocks.push({\n          node,\n          visible\n        });\n      }\n    }\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    } else {\n      if (!node) {\n        node = new ConstantNode(undefined);\n        if (state.comment) {\n          node.comment = state.comment;\n        }\n      }\n      return node;\n    }\n  }\n\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n  function parseAssignment(state) {\n    var name, args, value, valid;\n    var node = parseConditional(state);\n    if (state.token === '=') {\n      if (isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(new SymbolNode(name), value);\n      } else if (isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        if (node.optionalChaining) {\n          throw createSyntaxError(state, 'Cannot assign to optional chain');\n        }\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(node.object, node.index, value);\n      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (isSymbolNode(arg)) {\n            args[index] = arg.name;\n          } else {\n            valid = false;\n          }\n        });\n        if (valid) {\n          getTokenSkipNewline(state);\n          value = parseAssignment(state);\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\n    }\n    return node;\n  }\n\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n  function parseConditional(state) {\n    var node = parseLogicalOr(state);\n    while (state.token === '?') {\n      // eslint-disable-line no-unmodified-loop-condition\n      // set a conditional level, the range operator will be ignored as long\n      // as conditionalLevel === state.nestingLevel.\n      var prev = state.conditionalLevel;\n      state.conditionalLevel = state.nestingLevel;\n      getTokenSkipNewline(state);\n      var condition = node;\n      var trueExpr = parseAssignment(state);\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\n      state.conditionalLevel = null;\n      getTokenSkipNewline(state);\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr);\n\n      // restore the previous conditional level\n      state.conditionalLevel = prev;\n    }\n    return node;\n  }\n\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalOr(state) {\n    var node = parseLogicalXor(state);\n    while (state.token === 'or') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalXor(state) {\n    var node = parseLogicalAnd(state);\n    while (state.token === 'xor') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalAnd(state) {\n    var node = parseBitwiseOr(state);\n    while (state.token === 'and') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseOr(state) {\n    var node = parseBitwiseXor(state);\n    while (state.token === '|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseXor(state) {\n    var node = parseBitwiseAnd(state);\n    while (state.token === '^|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseAnd(state) {\n    var node = parseRelational(state);\n    while (state.token === '&') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * Parse a chained conditional, like 'a > b >= c'\n   * @return {Node} node\n   */\n  function parseRelational(state) {\n    var params = [parseShift(state)];\n    var conditionals = [];\n    var operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n    while (hasOwnProperty(operators, state.token)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      var cond = {\n        name: state.token,\n        fn: operators[state.token]\n      };\n      conditionals.push(cond);\n      getTokenSkipNewline(state);\n      params.push(parseShift(state));\n    }\n    if (params.length === 1) {\n      return params[0];\n    } else if (params.length === 2) {\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\n    } else {\n      return new RelationalNode(conditionals.map(c => c.fn), params);\n    }\n  }\n\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n  function parseShift(state) {\n    var node, name, fn, params;\n    node = parseConversion(state);\n    var operators = {\n      '<<': 'leftShift',\n      '>>': 'rightArithShift',\n      '>>>': 'rightLogShift'\n    };\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseConversion(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n    return node;\n  }\n\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n  function parseConversion(state) {\n    var node, name, fn, params;\n    node = parseRange(state);\n    var operators = {\n      to: 'to',\n      in: 'to' // alias of 'to'\n    };\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      if (name === 'in' && '])},;'.includes(state.token)) {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      } else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n    return node;\n  }\n\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n  function parseRange(state) {\n    var node;\n    var params = [];\n    if (state.token === ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode(1);\n    } else {\n      // explicit start\n      node = parseAddSubtract(state);\n    }\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node);\n\n      // parse step and end\n      while (state.token === ':' && params.length < 3) {\n        // eslint-disable-line no-unmodified-loop-condition\n        getTokenSkipNewline(state);\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        } else {\n          // explicit end\n          params.push(parseAddSubtract(state));\n        }\n      }\n      if (params.length === 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      } else {\n        // length === 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n    return node;\n  }\n\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n  function parseAddSubtract(state) {\n    var node, name, fn, params;\n    node = parseMultiplyDivideModulus(state);\n    var operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      var rightNode = parseMultiplyDivideModulus(state);\n      if (rightNode.isPercentage) {\n        params = [node, new OperatorNode('*', 'multiply', [node, rightNode])];\n      } else {\n        params = [node, rightNode];\n      }\n      node = new OperatorNode(name, fn, params);\n    }\n    return node;\n  }\n\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n  function parseMultiplyDivideModulus(state) {\n    var node, last, name, fn;\n    node = parseImplicitMultiplication(state);\n    last = node;\n    var operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide',\n      '%': 'mod',\n      mod: 'mod'\n    };\n    while (true) {\n      if (hasOwnProperty(operators, state.token)) {\n        // explicit operators\n        name = state.token;\n        fn = operators[name];\n        getTokenSkipNewline(state);\n        last = parseImplicitMultiplication(state);\n        node = new OperatorNode(name, fn, [node, last]);\n      } else {\n        break;\n      }\n    }\n    return node;\n  }\n\n  /**\n   * implicit multiplication\n   * @return {Node} node\n   * @private\n   */\n  function parseImplicitMultiplication(state) {\n    var node, last;\n    node = parseRule2(state);\n    last = node;\n    while (true) {\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && isConstantNode(node) || state.token === 'in' && isOperatorNode(node) && node.fn === 'unaryMinus' && isConstantNode(node.args[0]) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === '!') || state.token === '(') {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseRule2(state);\n        node = new OperatorNode('*', 'multiply', [node, last], true /* implicit */);\n      } else {\n        break;\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\n   * And as amended in https://github.com/josdejong/mathjs/issues/2370#issuecomment-1054052164\n   * Explicit division gets higher precedence than implicit multiplication\n   * when the division matches this pattern:\n   *   [unaryPrefixOp]?[number] / [number] [symbol]\n   * @return {Node} node\n   * @private\n   */\n  function parseRule2(state) {\n    var node = parseUnaryPercentage(state);\n    var last = node;\n    var tokenStates = [];\n    while (true) {\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\n      if (state.token === '/' && rule2Node(last)) {\n        // Look ahead to see if the next token is a number\n        tokenStates.push(_extends({}, state));\n        getTokenSkipNewline(state);\n\n        // Match the \"number / number\" part of the pattern\n        if (state.tokenType === TOKENTYPE.NUMBER) {\n          // Look ahead again\n          tokenStates.push(_extends({}, state));\n          getTokenSkipNewline(state);\n\n          // Match the \"symbol\" part of the pattern, or a left parenthesis\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(' || state.token === 'in') {\n            // We've matched the pattern \"number / number symbol\".\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\n            _extends(state, tokenStates.pop());\n            tokenStates.pop();\n            last = parseUnaryPercentage(state);\n            node = new OperatorNode('/', 'divide', [node, last]);\n          } else {\n            // Not a match, so rewind\n            tokenStates.pop();\n            _extends(state, tokenStates.pop());\n            break;\n          }\n        } else {\n          // Not a match, so rewind\n          _extends(state, tokenStates.pop());\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Unary percentage operator (treated as `value / 100`)\n   * @return {Node} node\n   * @private\n   */\n  function parseUnaryPercentage(state) {\n    var node = parseUnary(state);\n    if (state.token === '%') {\n      var previousState = _extends({}, state);\n      getTokenSkipNewline(state);\n      // We need to decide if this is a unary percentage % or binary modulo %\n      // So we attempt to parse a unary expression at this point.\n      // If it fails, then the only possibility is that this is a unary percentage.\n      // If it succeeds, then we presume that this must be binary modulo, since the\n      // only things that parseUnary can handle are _higher_ precedence than unary %.\n      try {\n        parseUnary(state);\n        // Not sure if we could somehow use the result of that parseUnary? Without\n        // further analysis/testing, safer just to discard and let the parse proceed\n        _extends(state, previousState);\n      } catch (_unused) {\n        // Not seeing a term at this point, so was a unary %\n        node = new OperatorNode('/', 'divide', [node, new ConstantNode(100)], false, true);\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n  function parseUnary(state) {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      not: 'not'\n    };\n    if (hasOwnProperty(operators, state.token)) {\n      fn = operators[state.token];\n      name = state.token;\n      getTokenSkipNewline(state);\n      params = [parseUnary(state)];\n      return new OperatorNode(name, fn, params);\n    }\n    return parsePow(state);\n  }\n\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n  function parsePow(state) {\n    var node, name, fn, params;\n    node = parseNullishCoalescing(state);\n    if (state.token === '^' || state.token === '.^') {\n      name = state.token;\n      fn = name === '^' ? 'pow' : 'dotPow';\n      getTokenSkipNewline(state);\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\n      node = new OperatorNode(name, fn, params);\n    }\n    return node;\n  }\n\n  /**\n   * nullish coalescing operator\n   * @return {Node} node\n   * @private\n   */\n  function parseNullishCoalescing(state) {\n    var node = parseLeftHandOperators(state);\n    while (state.token === '??') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('??', 'nullish', [node, parseLeftHandOperators(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * Left hand operators: factorial x!, ctranspose x'\n   * @return {Node} node\n   * @private\n   */\n  function parseLeftHandOperators(state) {\n    var node, name, fn, params;\n    node = parseCustomNodes(state);\n    var operators = {\n      '!': 'factorial',\n      '\\'': 'ctranspose'\n    };\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getToken(state);\n      params = [node];\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(state, node);\n    }\n    return node;\n  }\n\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     }\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params)\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes)\n   *\n   * @return {Node} node\n   * @private\n   */\n  function parseCustomNodes(state) {\n    var params = [];\n    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {\n      var CustomNode = state.extraNodes[state.token];\n      getToken(state);\n\n      // parse parameters\n      if (state.token === '(') {\n        params = [];\n        openParams(state);\n        getToken(state);\n        if (state.token !== ')') {\n          params.push(parseAssignment(state));\n\n          // parse a list with parameters\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n        if (state.token !== ')') {\n          throw createSyntaxError(state, 'Parenthesis ) expected');\n        }\n        closeParams(state);\n        getToken(state);\n      }\n\n      // create a new custom node\n      // noinspection JSValidateTypes\n      return new CustomNode(params);\n    }\n    return parseSymbol(state);\n  }\n\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n  function parseSymbol(state) {\n    var node, name;\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n      name = state.token;\n      getToken(state);\n      if (hasOwnProperty(CONSTANTS, name)) {\n        // true, false, null, ...\n        node = new ConstantNode(CONSTANTS[name]);\n      } else if (NUMERIC_CONSTANTS.includes(name)) {\n        // NaN, Infinity\n        node = new ConstantNode(numeric(name, 'number'));\n      } else {\n        node = new SymbolNode(name);\n      }\n\n      // parse function parameters and matrix index\n      node = parseAccessors(state, node);\n      return node;\n    }\n    return parseString(state);\n  }\n\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2) or sqrt?.(2) with optional chaining\n   * - index enclosed in square brackets [...], for example A[2,3] or A?.[2,3] with optional chaining\n   * - dot notation for properties, like foo.bar or foo?.bar with optional chaining\n   * @param {Object} state\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n  function parseAccessors(state, node, types) {\n    var params;\n\n    // Iterate and handle chained accessors, including repeated optional chaining\n    while (true) {\n      // eslint-disable-line no-unmodified-loop-condition\n      // Track whether an optional chaining operator precedes the next accessor\n      var optional = false;\n\n      // Consume an optional chaining operator if present\n      if (state.token === '?.') {\n        optional = true;\n        // consume the '?.' token\n        getToken(state);\n      }\n      var hasNextAccessor = (state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.includes(state.token));\n      if (!(optional || hasNextAccessor)) {\n        break;\n      }\n      params = [];\n      if (state.token === '(') {\n        if (optional || isSymbolNode(node) || isAccessorNode(node)) {\n          // function invocation: fn(2, 3) or obj.fn(2, 3) or (anything)?.(2, 3)\n          openParams(state);\n          getToken(state);\n          if (state.token !== ')') {\n            params.push(parseAssignment(state));\n\n            // parse a list with parameters\n            while (state.token === ',') {\n              // eslint-disable-line no-unmodified-loop-condition\n              getToken(state);\n              params.push(parseAssignment(state));\n            }\n          }\n          if (state.token !== ')') {\n            throw createSyntaxError(state, 'Parenthesis ) expected');\n          }\n          closeParams(state);\n          getToken(state);\n          node = new FunctionNode(node, params, optional);\n        } else {\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\n          // don't parse it here but let it be handled by parseImplicitMultiplication\n          // with correct precedence\n          return node;\n        }\n      } else if (state.token === '[') {\n        // index notation like variable[2, 3]\n        openParams(state);\n        getToken(state);\n        if (state.token !== ']') {\n          params.push(parseAssignment(state));\n\n          // parse a list with parameters\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n        if (state.token !== ']') {\n          throw createSyntaxError(state, 'Parenthesis ] expected');\n        }\n        closeParams(state);\n        getToken(state);\n        node = new AccessorNode(node, new IndexNode(params), optional);\n      } else {\n        // dot notation like variable.prop\n        // consume the `.` (if it was ?., already consumed):\n        if (!optional) getToken(state);\n        var isPropertyName = state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS;\n        if (!isPropertyName) {\n          var message = 'Property name expected after ';\n          message += optional ? 'optional chain' : 'dot';\n          throw createSyntaxError(state, message);\n        }\n        params.push(new ConstantNode(state.token));\n        getToken(state);\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation), optional);\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Parse a single or double quoted string.\n   * @return {Node} node\n   * @private\n   */\n  function parseString(state) {\n    var node, str;\n    if (state.token === '\"' || state.token === \"'\") {\n      str = parseStringToken(state, state.token);\n\n      // create constant\n      node = new ConstantNode(str);\n\n      // parse index parameters\n      node = parseAccessors(state, node);\n      return node;\n    }\n    return parseMatrix(state);\n  }\n\n  /**\n   * Parse a string surrounded by single or double quotes\n   * @param {Object} state\n   * @param {\"'\" | \"\\\"\"} quote\n   * @return {string}\n   */\n  function parseStringToken(state, quote) {\n    var str = '';\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== quote) {\n      if (currentCharacter(state) === '\\\\') {\n        next(state);\n        var char = currentCharacter(state);\n        var escapeChar = ESCAPE_CHARACTERS[char];\n        if (escapeChar !== undefined) {\n          // an escaped control character like \\\" or \\n\n          str += escapeChar;\n          state.index += 1;\n        } else if (char === 'u') {\n          // escaped unicode character\n          var unicode = state.expression.slice(state.index + 1, state.index + 5);\n          if (/^[0-9A-Fa-f]{4}$/.test(unicode)) {\n            // test whether the string holds four hexadecimal values\n            str += String.fromCharCode(parseInt(unicode, 16));\n            state.index += 5;\n          } else {\n            throw createSyntaxError(state, \"Invalid unicode character \\\\u\".concat(unicode));\n          }\n        } else {\n          throw createSyntaxError(state, \"Bad escape character \\\\\".concat(char));\n        }\n      } else {\n        // any regular character\n        str += currentCharacter(state);\n        next(state);\n      }\n    }\n    getToken(state);\n    if (state.token !== quote) {\n      throw createSyntaxError(state, \"End of string \".concat(quote, \" expected\"));\n    }\n    getToken(state);\n    return str;\n  }\n\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n  function parseMatrix(state) {\n    var array, params, rows, cols;\n    if (state.token === '[') {\n      // matrix [...]\n      openParams(state);\n      getToken(state);\n      if (state.token !== ']') {\n        // this is a non-empty matrix\n        var row = parseRow(state);\n        if (state.token === ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row];\n\n          // the rows of the matrix are separated by dot-comma's\n          while (state.token === ';') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            if (state.token !== ']') {\n              params[rows] = parseRow(state);\n              rows++;\n            }\n          }\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n          closeParams(state);\n          getToken(state);\n\n          // check if the number of columns matches in all rows\n          cols = params[0].items.length;\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length !== cols) {\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\n            }\n          }\n          array = new ArrayNode(params);\n        } else {\n          // 1 dimensional vector\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n          closeParams(state);\n          getToken(state);\n          array = row;\n        }\n      } else {\n        // this is an empty matrix \"[ ]\"\n        closeParams(state);\n        getToken(state);\n        array = new ArrayNode([]);\n      }\n      return parseAccessors(state, array);\n    }\n    return parseObject(state);\n  }\n\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n  function parseRow(state) {\n    var params = [parseAssignment(state)];\n    var len = 1;\n    while (state.token === ',') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getToken(state);\n\n      // parse expression\n      if (state.token !== ']' && state.token !== ';') {\n        params[len] = parseAssignment(state);\n        len++;\n      }\n    }\n    return new ArrayNode(params);\n  }\n\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n  function parseObject(state) {\n    if (state.token === '{') {\n      openParams(state);\n      var key;\n      var properties = {};\n      do {\n        getToken(state);\n        if (state.token !== '}') {\n          // parse key\n          if (state.token === '\"' || state.token === \"'\") {\n            key = parseStringToken(state, state.token);\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n            key = state.token;\n            getToken(state);\n          } else {\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\n          }\n\n          // parse key/value separator\n          if (state.token !== ':') {\n            throw createSyntaxError(state, 'Colon : expected after object key');\n          }\n          getToken(state);\n\n          // parse key\n          properties[key] = parseAssignment(state);\n        }\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\n\n      if (state.token !== '}') {\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\n      }\n      closeParams(state);\n      getToken(state);\n      var node = new ObjectNode(properties);\n\n      // parse index parameters\n      node = parseAccessors(state, node);\n      return node;\n    }\n    return parseNumber(state);\n  }\n\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n  function parseNumber(state) {\n    var numberStr;\n    if (state.tokenType === TOKENTYPE.NUMBER) {\n      // this is a number\n      numberStr = state.token;\n      getToken(state);\n      var numericType = safeNumberType(numberStr, config);\n      var value = numeric(numberStr, numericType);\n      return new ConstantNode(value);\n    }\n    return parseParentheses(state);\n  }\n\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n  function parseParentheses(state) {\n    var node;\n\n    // check if it is a parenthesized expression\n    if (state.token === '(') {\n      // parentheses (...)\n      openParams(state);\n      getToken(state);\n      node = parseAssignment(state); // start again\n\n      if (state.token !== ')') {\n        throw createSyntaxError(state, 'Parenthesis ) expected');\n      }\n      closeParams(state);\n      getToken(state);\n      node = new ParenthesisNode(node);\n      node = parseAccessors(state, node);\n      return node;\n    }\n    return parseEnd(state);\n  }\n\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n  function parseEnd(state) {\n    if (state.token === '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError(state, 'Unexpected end of expression');\n    } else {\n      throw createSyntaxError(state, 'Value expected');\n    }\n  }\n\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last state.token starts\n   * @private\n   */\n  function col(state) {\n    return state.index - state.token.length + 1;\n  }\n\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n  function createSyntaxError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n  function createError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n\n  // Now that we can parse, automatically convert strings to Nodes by parsing\n  typed.addConversion({\n    from: 'string',\n    to: 'Node',\n    convert: parse\n  });\n  return parse;\n});","map":{"version":3,"names":["_extends","factory","isAccessorNode","isConstantNode","isFunctionNode","isOperatorNode","isSymbolNode","rule2Node","deepMap","safeNumberType","hasOwnProperty","name","dependencies","createParse","_ref","typed","numeric","config","AccessorNode","ArrayNode","AssignmentNode","BlockNode","ConditionalNode","ConstantNode","FunctionAssignmentNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","RangeNode","RelationalNode","SymbolNode","parse","string","expression","parseStart","Array__Matrix","expressions","parseMultiple","string_Object","options","extraNodes","nodes","undefined","arguments","length","elem","TypeError","TOKENTYPE","NULL","DELIMITER","NUMBER","SYMBOL","UNKNOWN","DELIMITERS","NAMED_DELIMITERS","mod","to","in","and","xor","or","not","CONSTANTS","true","false","null","NUMERIC_CONSTANTS","ESCAPE_CHARACTERS","b","f","n","r","t","initialState","comment","index","token","tokenType","nestingLevel","conditionalLevel","currentString","state","substr","currentCharacter","next","prevCharacter","charAt","nextCharacter","getToken","isWhitespace","c1","c2","c3","isDigit","isDigitDot","_c","isAlpha","isDecimalMark","createSyntaxError","getTokenSkipNewline","openParams","closeParams","c","cPrev","cNext","isValidLatinOrGreek","isValidMathSymbol","test","high","low","node","parseBlock","createError","blocks","visible","parseAssignment","push","args","value","valid","parseConditional","optionalChaining","object","fn","forEach","arg","parseLogicalOr","prev","condition","trueExpr","falseExpr","parseLogicalXor","parseLogicalAnd","parseBitwiseOr","parseBitwiseXor","parseBitwiseAnd","parseRelational","params","parseShift","conditionals","operators","cond","map","parseConversion","parseRange","includes","parseAddSubtract","parseMultiplyDivideModulus","rightNode","isPercentage","last","parseImplicitMultiplication","parseRule2","op","parseUnaryPercentage","tokenStates","pop","parseUnary","previousState","_unused","parsePow","parseNullishCoalescing","parseLeftHandOperators","parseCustomNodes","parseAccessors","CustomNode","parseSymbol","parseString","types","optional","hasNextAccessor","isPropertyName","message","dotNotation","str","parseStringToken","parseMatrix","quote","char","escapeChar","unicode","slice","String","fromCharCode","parseInt","concat","array","rows","cols","row","parseRow","items","parseObject","len","key","properties","parseNumber","numberStr","numericType","parseParentheses","parseEnd","col","error","SyntaxError","addConversion","from","convert"],"sources":["C:/Users/dudet/Documents/gitexp/CampusEats/node_modules/mathjs/lib/esm/expression/parse.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\nimport { factory } from '../utils/factory.js';\nimport { isAccessorNode, isConstantNode, isFunctionNode, isOperatorNode, isSymbolNode, rule2Node } from '../utils/is.js';\nimport { deepMap } from '../utils/collection.js';\nimport { safeNumberType } from '../utils/number.js';\nimport { hasOwnProperty } from '../utils/object.js';\nvar name = 'parse';\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\nexport var createParse = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    numeric,\n    config,\n    AccessorNode,\n    ArrayNode,\n    AssignmentNode,\n    BlockNode,\n    ConditionalNode,\n    ConstantNode,\n    FunctionAssignmentNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    RangeNode,\n    RelationalNode,\n    SymbolNode\n  } = _ref;\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.evaluate() or transformed into a functional object via node.compile().\n   *\n   * Note the evaluating arbitrary expressions may involve security risks,\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\n   *\n   * Syntax:\n   *\n   *     math.parse(expr)\n   *     math.parse(expr, options)\n   *     math.parse([expr1, expr2, expr3, ...])\n   *     math.parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\n   *     node1.compile().evaluate() // 5\n   *\n   *     let scope = {a:3, b:4}\n   *     const node2 = math.parse('a * b')\n   *     node2.evaluate(scope) // 12\n   *     const code2 = node2.compile()\n   *     code2.evaluate(scope) // 12\n   *     scope.a = 5\n   *     code2.evaluate(scope) // 20\n   *\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].compile().evaluate() // 12\n   *\n   * See also:\n   *\n   *     evaluate, compile\n   *\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n  var parse = typed(name, {\n    string: function string(expression) {\n      return parseStart(expression, {});\n    },\n    'Array | Matrix': function Array__Matrix(expressions) {\n      return parseMultiple(expressions, {});\n    },\n    'string, Object': function string_Object(expression, options) {\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\n      return parseStart(expression, extraNodes);\n    },\n    'Array | Matrix, Object': parseMultiple\n  });\n  function parseMultiple(expressions) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var extraNodes = options.nodes !== undefined ? options.nodes : {};\n\n    // parse an array or matrix with expressions\n    return deepMap(expressions, function (elem) {\n      if (typeof elem !== 'string') throw new TypeError('String expected');\n      return parseStart(elem, extraNodes);\n    });\n  }\n\n  // token types enumeration\n  var TOKENTYPE = {\n    NULL: 0,\n    DELIMITER: 1,\n    NUMBER: 2,\n    SYMBOL: 3,\n    UNKNOWN: 4\n  };\n\n  // map with all delimiters\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\"': true,\n    '\\'': true,\n    ';': true,\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '=': true,\n    ':': true,\n    '?': true,\n    '?.': true,\n    '??': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  };\n\n  // map with all named delimiters\n  var NAMED_DELIMITERS = {\n    mod: true,\n    to: true,\n    in: true,\n    and: true,\n    xor: true,\n    or: true,\n    not: true\n  };\n  var CONSTANTS = {\n    true: true,\n    false: false,\n    null: null,\n    undefined\n  };\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\n  var ESCAPE_CHARACTERS = {\n    '\"': '\"',\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '/': '/',\n    b: '\\b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t'\n    // note that \\u is handled separately in parseStringToken()\n  };\n  function initialState() {\n    return {\n      extraNodes: {},\n      // current extra nodes, must be careful not to mutate\n      expression: '',\n      // current expression\n      comment: '',\n      // last parsed comment\n      index: 0,\n      // current index in expr\n      token: '',\n      // current token\n      tokenType: TOKENTYPE.NULL,\n      // type of the token\n      nestingLevel: 0,\n      // level of nesting inside parameters, used to ignore newline characters\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\n    };\n  }\n\n  /**\n   * View upto `length` characters of the expression starting at the current character.\n   *\n   * @param {Object} state\n   * @param {number} [length=1] Number of characters to view\n   * @returns {string}\n   * @private\n   */\n  function currentString(state, length) {\n    return state.expression.substr(state.index, length);\n  }\n\n  /**\n   * View the current character. Returns '' if end of expression is reached.\n   *\n   * @param {Object} state\n   * @returns {string}\n   * @private\n   */\n  function currentCharacter(state) {\n    return currentString(state, 1);\n  }\n\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n  function next(state) {\n    state.index++;\n  }\n\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function prevCharacter(state) {\n    return state.expression.charAt(state.index - 1);\n  }\n\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n  function nextCharacter(state) {\n    return state.expression.charAt(state.index + 1);\n  }\n\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and tokenType\n   * @private\n   */\n  function getToken(state) {\n    state.tokenType = TOKENTYPE.NULL;\n    state.token = '';\n    state.comment = '';\n\n    // skip over ignored characters:\n    while (true) {\n      // comments:\n      if (currentCharacter(state) === '#') {\n        while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\n          state.comment += currentCharacter(state);\n          next(state);\n        }\n      }\n      // whitespace: space, tab, and newline when inside parameters\n      if (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\n        next(state);\n      } else {\n        break;\n      }\n    }\n\n    // check for end of expression\n    if (currentCharacter(state) === '') {\n      // token is still empty\n      state.tokenType = TOKENTYPE.DELIMITER;\n      return;\n    }\n\n    // check for new line character\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = currentCharacter(state);\n      next(state);\n      return;\n    }\n    var c1 = currentCharacter(state);\n    var c2 = currentString(state, 2);\n    var c3 = currentString(state, 3);\n    if (c3.length === 3 && DELIMITERS[c3]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c3;\n      next(state);\n      next(state);\n      next(state);\n      return;\n    }\n\n    // check for delimiters consisting of 2 characters\n    // Special case: the check for '?.' is to prevent a case like 'a?.3:.7' from being interpreted as optional chaining\n    // TODO: refactor the tokenization into some better way to deal with cases like 'a?.3:.7', see https://github.com/josdejong/mathjs/pull/3584\n    if (c2.length === 2 && DELIMITERS[c2] && (c2 !== '?.' || !parse.isDigit(state.expression.charAt(state.index + 2)))) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c2;\n      next(state);\n      next(state);\n      return;\n    }\n\n    // check for delimiters consisting of 1 character\n    if (DELIMITERS[c1]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c1;\n      next(state);\n      return;\n    }\n\n    // check for a number\n    if (parse.isDigitDot(c1)) {\n      state.tokenType = TOKENTYPE.NUMBER;\n\n      // check for binary, octal, or hex\n      var _c = currentString(state, 2);\n      if (_c === '0b' || _c === '0o' || _c === '0x') {\n        state.token += currentCharacter(state);\n        next(state);\n        state.token += currentCharacter(state);\n        next(state);\n        while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n        if (currentCharacter(state) === '.') {\n          // this number has a radix point\n          state.token += '.';\n          next(state);\n          // get the digits after the radix\n          while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        } else if (currentCharacter(state) === 'i') {\n          // this number has a word size suffix\n          state.token += 'i';\n          next(state);\n          // get the word size\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        }\n        return;\n      }\n\n      // get number, can have a single dot\n      if (currentCharacter(state) === '.') {\n        state.token += currentCharacter(state);\n        next(state);\n        if (!parse.isDigit(currentCharacter(state))) {\n          // this is no number, it is just a dot (can be dot notation)\n          state.tokenType = TOKENTYPE.DELIMITER;\n          return;\n        }\n      } else {\n        while (parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n      }\n      while (parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n      // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\n          state.token += currentCharacter(state);\n          next(state);\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n          // Scientific notation MUST be followed by an exponent\n          if (!parse.isDigit(currentCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n        } else if (parse.isDecimalMark(nextCharacter(state), state.expression.charAt(state.index + 2))) {\n          next(state);\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n        }\n      }\n      return;\n    }\n\n    // check for variables, functions, named operators\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {\n        state.tokenType = TOKENTYPE.DELIMITER;\n      } else {\n        state.tokenType = TOKENTYPE.SYMBOL;\n      }\n      return;\n    }\n\n    // something unknown is found, wrong characters -> a syntax error\n    state.tokenType = TOKENTYPE.UNKNOWN;\n    while (currentCharacter(state) !== '') {\n      state.token += currentCharacter(state);\n      next(state);\n    }\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\n  }\n\n  /**\n   * Get next token and skip newline tokens\n   */\n  function getTokenSkipNewline(state) {\n    do {\n      getToken(state);\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\n  }\n\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams(state) is called\n   */\n  function openParams(state) {\n    state.nestingLevel++;\n  }\n\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n  function closeParams(state) {\n    state.nestingLevel--;\n  }\n\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\n  };\n\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * https://unicode-table.com/en/\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c === ' ' || c === '\\t' || c === '\\u00A0' || c === '\\n' && nestingLevel > 0;\n  };\n\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n  parse.isDigitDot = function isDigitDot(c) {\n    return c >= '0' && c <= '9' || c === '.';\n  };\n\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n  parse.isDigit = function isDigit(c) {\n    return c >= '0' && c <= '9';\n  };\n\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n  function parseStart(expression, extraNodes) {\n    var state = initialState();\n    _extends(state, {\n      expression,\n      extraNodes\n    });\n    getToken(state);\n    var node = parseBlock(state);\n\n    // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and tokenType DELIMITER\n    if (state.token !== '') {\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\n        throw createError(state, 'Unexpected operator ' + state.token);\n      } else {\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n  function parseBlock(state) {\n    var node;\n    var blocks = [];\n    var visible;\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\n      node = parseAssignment(state);\n      if (state.comment) {\n        node.comment = state.comment;\n      }\n    }\n\n    // TODO: simplify this loop\n    while (state.token === '\\n' || state.token === ';') {\n      // eslint-disable-line no-unmodified-loop-condition\n      if (blocks.length === 0 && node) {\n        visible = state.token !== ';';\n        blocks.push({\n          node,\n          visible\n        });\n      }\n      getToken(state);\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\n        node = parseAssignment(state);\n        if (state.comment) {\n          node.comment = state.comment;\n        }\n        visible = state.token !== ';';\n        blocks.push({\n          node,\n          visible\n        });\n      }\n    }\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    } else {\n      if (!node) {\n        node = new ConstantNode(undefined);\n        if (state.comment) {\n          node.comment = state.comment;\n        }\n      }\n      return node;\n    }\n  }\n\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n  function parseAssignment(state) {\n    var name, args, value, valid;\n    var node = parseConditional(state);\n    if (state.token === '=') {\n      if (isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(new SymbolNode(name), value);\n      } else if (isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        if (node.optionalChaining) {\n          throw createSyntaxError(state, 'Cannot assign to optional chain');\n        }\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(node.object, node.index, value);\n      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (isSymbolNode(arg)) {\n            args[index] = arg.name;\n          } else {\n            valid = false;\n          }\n        });\n        if (valid) {\n          getTokenSkipNewline(state);\n          value = parseAssignment(state);\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\n    }\n    return node;\n  }\n\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n  function parseConditional(state) {\n    var node = parseLogicalOr(state);\n    while (state.token === '?') {\n      // eslint-disable-line no-unmodified-loop-condition\n      // set a conditional level, the range operator will be ignored as long\n      // as conditionalLevel === state.nestingLevel.\n      var prev = state.conditionalLevel;\n      state.conditionalLevel = state.nestingLevel;\n      getTokenSkipNewline(state);\n      var condition = node;\n      var trueExpr = parseAssignment(state);\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\n      state.conditionalLevel = null;\n      getTokenSkipNewline(state);\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr);\n\n      // restore the previous conditional level\n      state.conditionalLevel = prev;\n    }\n    return node;\n  }\n\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalOr(state) {\n    var node = parseLogicalXor(state);\n    while (state.token === 'or') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalXor(state) {\n    var node = parseLogicalAnd(state);\n    while (state.token === 'xor') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n  function parseLogicalAnd(state) {\n    var node = parseBitwiseOr(state);\n    while (state.token === 'and') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseOr(state) {\n    var node = parseBitwiseXor(state);\n    while (state.token === '|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseXor(state) {\n    var node = parseBitwiseAnd(state);\n    while (state.token === '^|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n  function parseBitwiseAnd(state) {\n    var node = parseRelational(state);\n    while (state.token === '&') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * Parse a chained conditional, like 'a > b >= c'\n   * @return {Node} node\n   */\n  function parseRelational(state) {\n    var params = [parseShift(state)];\n    var conditionals = [];\n    var operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n    while (hasOwnProperty(operators, state.token)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      var cond = {\n        name: state.token,\n        fn: operators[state.token]\n      };\n      conditionals.push(cond);\n      getTokenSkipNewline(state);\n      params.push(parseShift(state));\n    }\n    if (params.length === 1) {\n      return params[0];\n    } else if (params.length === 2) {\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\n    } else {\n      return new RelationalNode(conditionals.map(c => c.fn), params);\n    }\n  }\n\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n  function parseShift(state) {\n    var node, name, fn, params;\n    node = parseConversion(state);\n    var operators = {\n      '<<': 'leftShift',\n      '>>': 'rightArithShift',\n      '>>>': 'rightLogShift'\n    };\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseConversion(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n    return node;\n  }\n\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n  function parseConversion(state) {\n    var node, name, fn, params;\n    node = parseRange(state);\n    var operators = {\n      to: 'to',\n      in: 'to' // alias of 'to'\n    };\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      if (name === 'in' && '])},;'.includes(state.token)) {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      } else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n    return node;\n  }\n\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n  function parseRange(state) {\n    var node;\n    var params = [];\n    if (state.token === ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode(1);\n    } else {\n      // explicit start\n      node = parseAddSubtract(state);\n    }\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node);\n\n      // parse step and end\n      while (state.token === ':' && params.length < 3) {\n        // eslint-disable-line no-unmodified-loop-condition\n        getTokenSkipNewline(state);\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        } else {\n          // explicit end\n          params.push(parseAddSubtract(state));\n        }\n      }\n      if (params.length === 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      } else {\n        // length === 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n    return node;\n  }\n\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n  function parseAddSubtract(state) {\n    var node, name, fn, params;\n    node = parseMultiplyDivideModulus(state);\n    var operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      var rightNode = parseMultiplyDivideModulus(state);\n      if (rightNode.isPercentage) {\n        params = [node, new OperatorNode('*', 'multiply', [node, rightNode])];\n      } else {\n        params = [node, rightNode];\n      }\n      node = new OperatorNode(name, fn, params);\n    }\n    return node;\n  }\n\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n  function parseMultiplyDivideModulus(state) {\n    var node, last, name, fn;\n    node = parseImplicitMultiplication(state);\n    last = node;\n    var operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide',\n      '%': 'mod',\n      mod: 'mod'\n    };\n    while (true) {\n      if (hasOwnProperty(operators, state.token)) {\n        // explicit operators\n        name = state.token;\n        fn = operators[name];\n        getTokenSkipNewline(state);\n        last = parseImplicitMultiplication(state);\n        node = new OperatorNode(name, fn, [node, last]);\n      } else {\n        break;\n      }\n    }\n    return node;\n  }\n\n  /**\n   * implicit multiplication\n   * @return {Node} node\n   * @private\n   */\n  function parseImplicitMultiplication(state) {\n    var node, last;\n    node = parseRule2(state);\n    last = node;\n    while (true) {\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && isConstantNode(node) || state.token === 'in' && isOperatorNode(node) && node.fn === 'unaryMinus' && isConstantNode(node.args[0]) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === '!') || state.token === '(') {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseRule2(state);\n        node = new OperatorNode('*', 'multiply', [node, last], true /* implicit */);\n      } else {\n        break;\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\n   * And as amended in https://github.com/josdejong/mathjs/issues/2370#issuecomment-1054052164\n   * Explicit division gets higher precedence than implicit multiplication\n   * when the division matches this pattern:\n   *   [unaryPrefixOp]?[number] / [number] [symbol]\n   * @return {Node} node\n   * @private\n   */\n  function parseRule2(state) {\n    var node = parseUnaryPercentage(state);\n    var last = node;\n    var tokenStates = [];\n    while (true) {\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\n      if (state.token === '/' && rule2Node(last)) {\n        // Look ahead to see if the next token is a number\n        tokenStates.push(_extends({}, state));\n        getTokenSkipNewline(state);\n\n        // Match the \"number / number\" part of the pattern\n        if (state.tokenType === TOKENTYPE.NUMBER) {\n          // Look ahead again\n          tokenStates.push(_extends({}, state));\n          getTokenSkipNewline(state);\n\n          // Match the \"symbol\" part of the pattern, or a left parenthesis\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(' || state.token === 'in') {\n            // We've matched the pattern \"number / number symbol\".\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\n            _extends(state, tokenStates.pop());\n            tokenStates.pop();\n            last = parseUnaryPercentage(state);\n            node = new OperatorNode('/', 'divide', [node, last]);\n          } else {\n            // Not a match, so rewind\n            tokenStates.pop();\n            _extends(state, tokenStates.pop());\n            break;\n          }\n        } else {\n          // Not a match, so rewind\n          _extends(state, tokenStates.pop());\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Unary percentage operator (treated as `value / 100`)\n   * @return {Node} node\n   * @private\n   */\n  function parseUnaryPercentage(state) {\n    var node = parseUnary(state);\n    if (state.token === '%') {\n      var previousState = _extends({}, state);\n      getTokenSkipNewline(state);\n      // We need to decide if this is a unary percentage % or binary modulo %\n      // So we attempt to parse a unary expression at this point.\n      // If it fails, then the only possibility is that this is a unary percentage.\n      // If it succeeds, then we presume that this must be binary modulo, since the\n      // only things that parseUnary can handle are _higher_ precedence than unary %.\n      try {\n        parseUnary(state);\n        // Not sure if we could somehow use the result of that parseUnary? Without\n        // further analysis/testing, safer just to discard and let the parse proceed\n        _extends(state, previousState);\n      } catch (_unused) {\n        // Not seeing a term at this point, so was a unary %\n        node = new OperatorNode('/', 'divide', [node, new ConstantNode(100)], false, true);\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n  function parseUnary(state) {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      not: 'not'\n    };\n    if (hasOwnProperty(operators, state.token)) {\n      fn = operators[state.token];\n      name = state.token;\n      getTokenSkipNewline(state);\n      params = [parseUnary(state)];\n      return new OperatorNode(name, fn, params);\n    }\n    return parsePow(state);\n  }\n\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n  function parsePow(state) {\n    var node, name, fn, params;\n    node = parseNullishCoalescing(state);\n    if (state.token === '^' || state.token === '.^') {\n      name = state.token;\n      fn = name === '^' ? 'pow' : 'dotPow';\n      getTokenSkipNewline(state);\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\n      node = new OperatorNode(name, fn, params);\n    }\n    return node;\n  }\n\n  /**\n   * nullish coalescing operator\n   * @return {Node} node\n   * @private\n   */\n  function parseNullishCoalescing(state) {\n    var node = parseLeftHandOperators(state);\n    while (state.token === '??') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('??', 'nullish', [node, parseLeftHandOperators(state)]);\n    }\n    return node;\n  }\n\n  /**\n   * Left hand operators: factorial x!, ctranspose x'\n   * @return {Node} node\n   * @private\n   */\n  function parseLeftHandOperators(state) {\n    var node, name, fn, params;\n    node = parseCustomNodes(state);\n    var operators = {\n      '!': 'factorial',\n      '\\'': 'ctranspose'\n    };\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getToken(state);\n      params = [node];\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(state, node);\n    }\n    return node;\n  }\n\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     }\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params)\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes)\n   *\n   * @return {Node} node\n   * @private\n   */\n  function parseCustomNodes(state) {\n    var params = [];\n    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {\n      var CustomNode = state.extraNodes[state.token];\n      getToken(state);\n\n      // parse parameters\n      if (state.token === '(') {\n        params = [];\n        openParams(state);\n        getToken(state);\n        if (state.token !== ')') {\n          params.push(parseAssignment(state));\n\n          // parse a list with parameters\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n        if (state.token !== ')') {\n          throw createSyntaxError(state, 'Parenthesis ) expected');\n        }\n        closeParams(state);\n        getToken(state);\n      }\n\n      // create a new custom node\n      // noinspection JSValidateTypes\n      return new CustomNode(params);\n    }\n    return parseSymbol(state);\n  }\n\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n  function parseSymbol(state) {\n    var node, name;\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n      name = state.token;\n      getToken(state);\n      if (hasOwnProperty(CONSTANTS, name)) {\n        // true, false, null, ...\n        node = new ConstantNode(CONSTANTS[name]);\n      } else if (NUMERIC_CONSTANTS.includes(name)) {\n        // NaN, Infinity\n        node = new ConstantNode(numeric(name, 'number'));\n      } else {\n        node = new SymbolNode(name);\n      }\n\n      // parse function parameters and matrix index\n      node = parseAccessors(state, node);\n      return node;\n    }\n    return parseString(state);\n  }\n\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2) or sqrt?.(2) with optional chaining\n   * - index enclosed in square brackets [...], for example A[2,3] or A?.[2,3] with optional chaining\n   * - dot notation for properties, like foo.bar or foo?.bar with optional chaining\n   * @param {Object} state\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n  function parseAccessors(state, node, types) {\n    var params;\n\n    // Iterate and handle chained accessors, including repeated optional chaining\n    while (true) {\n      // eslint-disable-line no-unmodified-loop-condition\n      // Track whether an optional chaining operator precedes the next accessor\n      var optional = false;\n\n      // Consume an optional chaining operator if present\n      if (state.token === '?.') {\n        optional = true;\n        // consume the '?.' token\n        getToken(state);\n      }\n      var hasNextAccessor = (state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.includes(state.token));\n      if (!(optional || hasNextAccessor)) {\n        break;\n      }\n      params = [];\n      if (state.token === '(') {\n        if (optional || isSymbolNode(node) || isAccessorNode(node)) {\n          // function invocation: fn(2, 3) or obj.fn(2, 3) or (anything)?.(2, 3)\n          openParams(state);\n          getToken(state);\n          if (state.token !== ')') {\n            params.push(parseAssignment(state));\n\n            // parse a list with parameters\n            while (state.token === ',') {\n              // eslint-disable-line no-unmodified-loop-condition\n              getToken(state);\n              params.push(parseAssignment(state));\n            }\n          }\n          if (state.token !== ')') {\n            throw createSyntaxError(state, 'Parenthesis ) expected');\n          }\n          closeParams(state);\n          getToken(state);\n          node = new FunctionNode(node, params, optional);\n        } else {\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\n          // don't parse it here but let it be handled by parseImplicitMultiplication\n          // with correct precedence\n          return node;\n        }\n      } else if (state.token === '[') {\n        // index notation like variable[2, 3]\n        openParams(state);\n        getToken(state);\n        if (state.token !== ']') {\n          params.push(parseAssignment(state));\n\n          // parse a list with parameters\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n        if (state.token !== ']') {\n          throw createSyntaxError(state, 'Parenthesis ] expected');\n        }\n        closeParams(state);\n        getToken(state);\n        node = new AccessorNode(node, new IndexNode(params), optional);\n      } else {\n        // dot notation like variable.prop\n        // consume the `.` (if it was ?., already consumed):\n        if (!optional) getToken(state);\n        var isPropertyName = state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS;\n        if (!isPropertyName) {\n          var message = 'Property name expected after ';\n          message += optional ? 'optional chain' : 'dot';\n          throw createSyntaxError(state, message);\n        }\n        params.push(new ConstantNode(state.token));\n        getToken(state);\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation), optional);\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Parse a single or double quoted string.\n   * @return {Node} node\n   * @private\n   */\n  function parseString(state) {\n    var node, str;\n    if (state.token === '\"' || state.token === \"'\") {\n      str = parseStringToken(state, state.token);\n\n      // create constant\n      node = new ConstantNode(str);\n\n      // parse index parameters\n      node = parseAccessors(state, node);\n      return node;\n    }\n    return parseMatrix(state);\n  }\n\n  /**\n   * Parse a string surrounded by single or double quotes\n   * @param {Object} state\n   * @param {\"'\" | \"\\\"\"} quote\n   * @return {string}\n   */\n  function parseStringToken(state, quote) {\n    var str = '';\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== quote) {\n      if (currentCharacter(state) === '\\\\') {\n        next(state);\n        var char = currentCharacter(state);\n        var escapeChar = ESCAPE_CHARACTERS[char];\n        if (escapeChar !== undefined) {\n          // an escaped control character like \\\" or \\n\n          str += escapeChar;\n          state.index += 1;\n        } else if (char === 'u') {\n          // escaped unicode character\n          var unicode = state.expression.slice(state.index + 1, state.index + 5);\n          if (/^[0-9A-Fa-f]{4}$/.test(unicode)) {\n            // test whether the string holds four hexadecimal values\n            str += String.fromCharCode(parseInt(unicode, 16));\n            state.index += 5;\n          } else {\n            throw createSyntaxError(state, \"Invalid unicode character \\\\u\".concat(unicode));\n          }\n        } else {\n          throw createSyntaxError(state, \"Bad escape character \\\\\".concat(char));\n        }\n      } else {\n        // any regular character\n        str += currentCharacter(state);\n        next(state);\n      }\n    }\n    getToken(state);\n    if (state.token !== quote) {\n      throw createSyntaxError(state, \"End of string \".concat(quote, \" expected\"));\n    }\n    getToken(state);\n    return str;\n  }\n\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n  function parseMatrix(state) {\n    var array, params, rows, cols;\n    if (state.token === '[') {\n      // matrix [...]\n      openParams(state);\n      getToken(state);\n      if (state.token !== ']') {\n        // this is a non-empty matrix\n        var row = parseRow(state);\n        if (state.token === ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row];\n\n          // the rows of the matrix are separated by dot-comma's\n          while (state.token === ';') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            if (state.token !== ']') {\n              params[rows] = parseRow(state);\n              rows++;\n            }\n          }\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n          closeParams(state);\n          getToken(state);\n\n          // check if the number of columns matches in all rows\n          cols = params[0].items.length;\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length !== cols) {\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\n            }\n          }\n          array = new ArrayNode(params);\n        } else {\n          // 1 dimensional vector\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n          closeParams(state);\n          getToken(state);\n          array = row;\n        }\n      } else {\n        // this is an empty matrix \"[ ]\"\n        closeParams(state);\n        getToken(state);\n        array = new ArrayNode([]);\n      }\n      return parseAccessors(state, array);\n    }\n    return parseObject(state);\n  }\n\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n  function parseRow(state) {\n    var params = [parseAssignment(state)];\n    var len = 1;\n    while (state.token === ',') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getToken(state);\n\n      // parse expression\n      if (state.token !== ']' && state.token !== ';') {\n        params[len] = parseAssignment(state);\n        len++;\n      }\n    }\n    return new ArrayNode(params);\n  }\n\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n  function parseObject(state) {\n    if (state.token === '{') {\n      openParams(state);\n      var key;\n      var properties = {};\n      do {\n        getToken(state);\n        if (state.token !== '}') {\n          // parse key\n          if (state.token === '\"' || state.token === \"'\") {\n            key = parseStringToken(state, state.token);\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n            key = state.token;\n            getToken(state);\n          } else {\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\n          }\n\n          // parse key/value separator\n          if (state.token !== ':') {\n            throw createSyntaxError(state, 'Colon : expected after object key');\n          }\n          getToken(state);\n\n          // parse key\n          properties[key] = parseAssignment(state);\n        }\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\n\n      if (state.token !== '}') {\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\n      }\n      closeParams(state);\n      getToken(state);\n      var node = new ObjectNode(properties);\n\n      // parse index parameters\n      node = parseAccessors(state, node);\n      return node;\n    }\n    return parseNumber(state);\n  }\n\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n  function parseNumber(state) {\n    var numberStr;\n    if (state.tokenType === TOKENTYPE.NUMBER) {\n      // this is a number\n      numberStr = state.token;\n      getToken(state);\n      var numericType = safeNumberType(numberStr, config);\n      var value = numeric(numberStr, numericType);\n      return new ConstantNode(value);\n    }\n    return parseParentheses(state);\n  }\n\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n  function parseParentheses(state) {\n    var node;\n\n    // check if it is a parenthesized expression\n    if (state.token === '(') {\n      // parentheses (...)\n      openParams(state);\n      getToken(state);\n      node = parseAssignment(state); // start again\n\n      if (state.token !== ')') {\n        throw createSyntaxError(state, 'Parenthesis ) expected');\n      }\n      closeParams(state);\n      getToken(state);\n      node = new ParenthesisNode(node);\n      node = parseAccessors(state, node);\n      return node;\n    }\n    return parseEnd(state);\n  }\n\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n  function parseEnd(state) {\n    if (state.token === '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError(state, 'Unexpected end of expression');\n    } else {\n      throw createSyntaxError(state, 'Value expected');\n    }\n  }\n\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last state.token starts\n   * @private\n   */\n  function col(state) {\n    return state.index - state.token.length + 1;\n  }\n\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n  function createSyntaxError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n  function createError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n\n  // Now that we can parse, automatically convert strings to Nodes by parsing\n  typed.addConversion({\n    from: 'string',\n    to: 'Node',\n    convert: parse\n  });\n  return parse;\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}