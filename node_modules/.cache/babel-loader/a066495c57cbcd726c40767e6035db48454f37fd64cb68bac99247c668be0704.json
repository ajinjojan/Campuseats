{"ast":null,"code":"import { Texture } from '../core/Texture.js';\nimport { KTXTexture } from './KTXTexture.js';\n\n// For compressed textures, generate using https://github.com/TimvanScherpenzeel/texture-compressor\n\nlet cache = {};\nconst supportedExtensions = [];\nexport class TextureLoader {\n  static load(gl) {\n    let {\n      src,\n      // string or object of extension:src key-values\n      // {\n      //     pvrtc: '...ktx',\n      //     s3tc: '...ktx',\n      //     etc: '...ktx',\n      //     etc1: '...ktx',\n      //     astc: '...ktx',\n      //     webp: '...webp',\n      //     jpg: '...jpg',\n      //     png: '...png',\n      // }\n\n      // Only props relevant to KTXTexture\n      wrapS = gl.CLAMP_TO_EDGE,\n      wrapT = gl.CLAMP_TO_EDGE,\n      anisotropy = 0,\n      // For regular images\n      format = gl.RGBA,\n      internalFormat = format,\n      generateMipmaps = true,\n      minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n      magFilter = gl.LINEAR,\n      premultiplyAlpha = false,\n      unpackAlignment = 4,\n      flipY = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const support = this.getSupportedExtensions(gl);\n    let ext = 'none';\n\n    // If src is string, determine which format from the extension\n    if (typeof src === 'string') {\n      ext = src.split('.').pop().split('?')[0].toLowerCase();\n    }\n\n    // If src is object, use supported extensions and provided list to choose best option\n    // Get first supported match, so put in order of preference\n    if (typeof src === 'object') {\n      for (const prop in src) {\n        if (support.includes(prop.toLowerCase())) {\n          ext = prop.toLowerCase();\n          src = src[prop];\n          break;\n        }\n      }\n    }\n\n    // Stringify props\n    const cacheID = src + wrapS + wrapT + anisotropy + format + internalFormat + generateMipmaps + minFilter + magFilter + premultiplyAlpha + unpackAlignment + flipY + gl.renderer.id;\n\n    // Check cache for existing texture\n    if (cache[cacheID]) return cache[cacheID];\n    let texture;\n    switch (ext) {\n      case 'ktx':\n      case 'pvrtc':\n      case 's3tc':\n      case 'etc':\n      case 'etc1':\n      case 'astc':\n        // Load compressed texture using KTX format\n        texture = new KTXTexture(gl, {\n          src,\n          wrapS,\n          wrapT,\n          anisotropy,\n          minFilter,\n          magFilter\n        });\n        texture.loaded = this.loadKTX(src, texture);\n        break;\n      case 'webp':\n      case 'jpg':\n      case 'jpeg':\n      case 'png':\n        texture = new Texture(gl, {\n          wrapS,\n          wrapT,\n          anisotropy,\n          format,\n          internalFormat,\n          generateMipmaps,\n          minFilter,\n          magFilter,\n          premultiplyAlpha,\n          unpackAlignment,\n          flipY\n        });\n        texture.loaded = this.loadImage(gl, src, texture, flipY);\n        break;\n      default:\n        console.warn('No supported format supplied');\n        texture = new Texture(gl);\n    }\n    texture.ext = ext;\n    cache[cacheID] = texture;\n    return texture;\n  }\n  static getSupportedExtensions(gl) {\n    if (supportedExtensions.length) return supportedExtensions;\n    const extensions = {\n      pvrtc: gl.renderer.getExtension('WEBGL_compressed_texture_pvrtc') || gl.renderer.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n      s3tc: gl.renderer.getExtension('WEBGL_compressed_texture_s3tc'),\n      // etc: gl.renderer.getExtension('WEBGL_compressed_texture_etc'),\n      etc1: gl.renderer.getExtension('WEBGL_compressed_texture_etc1'),\n      astc: gl.renderer.getExtension('WEBGL_compressed_texture_astc'),\n      bc7: gl.renderer.getExtension('EXT_texture_compression_bptc')\n    };\n    for (const ext in extensions) if (extensions[ext]) supportedExtensions.push(ext);\n\n    // Formats supported by all\n    supportedExtensions.push('png', 'jpg', 'webp');\n    return supportedExtensions;\n  }\n  static loadKTX(src, texture) {\n    return fetch(src).then(res => res.arrayBuffer()).then(buffer => texture.parseBuffer(buffer));\n  }\n  static loadImage(gl, src, texture, flipY) {\n    return decodeImage(src, flipY).then(imgBmp => {\n      // Catch non POT textures for WebGL1 and update params to avoid errors\n      if (!gl.renderer.isWebgl2 && (!powerOfTwo(imgBmp.width) || !powerOfTwo(imgBmp.height))) {\n        if (texture.generateMipmaps) texture.generateMipmaps = false;\n        if (texture.minFilter === gl.NEAREST_MIPMAP_LINEAR) texture.minFilter = gl.LINEAR;\n        if (texture.wrapS === gl.REPEAT) texture.wrapS = texture.wrapT = gl.CLAMP_TO_EDGE;\n      }\n      texture.image = imgBmp;\n\n      // For createImageBitmap, close once uploaded\n      texture.onUpdate = () => {\n        if (imgBmp.close) imgBmp.close();\n        texture.onUpdate = null;\n      };\n      return imgBmp;\n    });\n  }\n  static clearCache() {\n    cache = {};\n  }\n}\nfunction powerOfTwo(value) {\n  // (width & (width - 1)) !== 0\n  return Math.log2(value) % 1 === 0;\n}\nfunction decodeImage(src, flipY) {\n  return new Promise((resolve, reject) => {\n    if (isCreateImageBitmap()) {\n      fetch(src, {\n        mode: 'cors'\n      }).then(r => r.blob()).then(b => createImageBitmap(b, {\n        imageOrientation: flipY ? 'flipY' : 'none',\n        premultiplyAlpha: 'none'\n      })).then(resolve).catch(err => reject(err));\n    } else {\n      const img = new Image();\n      img.crossOrigin = '';\n      img.src = src;\n      img.onerror = _ref => {\n        let {\n          type\n        } = _ref;\n        return reject(\"\".concat(type, \": Loading image\"));\n      };\n      img.onload = () => resolve(img);\n    }\n  });\n}\nfunction isCreateImageBitmap() {\n  const isChrome = navigator.userAgent.toLowerCase().includes('chrome');\n  if (!isChrome) return false;\n  try {\n    createImageBitmap;\n  } catch (e) {\n    return false;\n  }\n  return true;\n}","map":{"version":3,"names":["Texture","KTXTexture","cache","supportedExtensions","TextureLoader","load","gl","src","wrapS","CLAMP_TO_EDGE","wrapT","anisotropy","format","RGBA","internalFormat","generateMipmaps","minFilter","NEAREST_MIPMAP_LINEAR","LINEAR","magFilter","premultiplyAlpha","unpackAlignment","flipY","arguments","length","undefined","support","getSupportedExtensions","ext","split","pop","toLowerCase","prop","includes","cacheID","renderer","id","texture","loaded","loadKTX","loadImage","console","warn","extensions","pvrtc","getExtension","s3tc","etc1","astc","bc7","push","fetch","then","res","arrayBuffer","buffer","parseBuffer","decodeImage","imgBmp","isWebgl2","powerOfTwo","width","height","REPEAT","image","onUpdate","close","clearCache","value","Math","log2","Promise","resolve","reject","isCreateImageBitmap","mode","r","blob","b","createImageBitmap","imageOrientation","catch","err","img","Image","crossOrigin","onerror","_ref","type","concat","onload","isChrome","navigator","userAgent","e"],"sources":["C:/Users/dudet/Documents/gitexp/CampusEats/node_modules/ogl/src/extras/TextureLoader.js"],"sourcesContent":["import { Texture } from '../core/Texture.js';\r\nimport { KTXTexture } from './KTXTexture.js';\r\n\r\n// For compressed textures, generate using https://github.com/TimvanScherpenzeel/texture-compressor\r\n\r\nlet cache = {};\r\nconst supportedExtensions = [];\r\n\r\nexport class TextureLoader {\r\n    static load(\r\n        gl,\r\n        {\r\n            src, // string or object of extension:src key-values\r\n            // {\r\n            //     pvrtc: '...ktx',\r\n            //     s3tc: '...ktx',\r\n            //     etc: '...ktx',\r\n            //     etc1: '...ktx',\r\n            //     astc: '...ktx',\r\n            //     webp: '...webp',\r\n            //     jpg: '...jpg',\r\n            //     png: '...png',\r\n            // }\r\n\r\n            // Only props relevant to KTXTexture\r\n            wrapS = gl.CLAMP_TO_EDGE,\r\n            wrapT = gl.CLAMP_TO_EDGE,\r\n            anisotropy = 0,\r\n\r\n            // For regular images\r\n            format = gl.RGBA,\r\n            internalFormat = format,\r\n            generateMipmaps = true,\r\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\r\n            magFilter = gl.LINEAR,\r\n            premultiplyAlpha = false,\r\n            unpackAlignment = 4,\r\n            flipY = true,\r\n        } = {}\r\n    ) {\r\n        const support = this.getSupportedExtensions(gl);\r\n        let ext = 'none';\r\n\r\n        // If src is string, determine which format from the extension\r\n        if (typeof src === 'string') {\r\n            ext = src.split('.').pop().split('?')[0].toLowerCase();\r\n        }\r\n\r\n        // If src is object, use supported extensions and provided list to choose best option\r\n        // Get first supported match, so put in order of preference\r\n        if (typeof src === 'object') {\r\n            for (const prop in src) {\r\n                if (support.includes(prop.toLowerCase())) {\r\n                    ext = prop.toLowerCase();\r\n                    src = src[prop];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Stringify props\r\n        const cacheID = src + wrapS + wrapT + anisotropy + format + internalFormat + generateMipmaps + minFilter + magFilter + premultiplyAlpha + unpackAlignment + flipY + gl.renderer.id;\r\n\r\n        // Check cache for existing texture\r\n        if (cache[cacheID]) return cache[cacheID];\r\n\r\n        let texture;\r\n        switch (ext) {\r\n            case 'ktx':\r\n            case 'pvrtc':\r\n            case 's3tc':\r\n            case 'etc':\r\n            case 'etc1':\r\n            case 'astc':\r\n                // Load compressed texture using KTX format\r\n                texture = new KTXTexture(gl, {\r\n                    src,\r\n                    wrapS,\r\n                    wrapT,\r\n                    anisotropy,\r\n                    minFilter,\r\n                    magFilter,\r\n                });\r\n                texture.loaded = this.loadKTX(src, texture);\r\n                break;\r\n            case 'webp':\r\n            case 'jpg':\r\n            case 'jpeg':\r\n            case 'png':\r\n                texture = new Texture(gl, {\r\n                    wrapS,\r\n                    wrapT,\r\n                    anisotropy,\r\n                    format,\r\n                    internalFormat,\r\n                    generateMipmaps,\r\n                    minFilter,\r\n                    magFilter,\r\n                    premultiplyAlpha,\r\n                    unpackAlignment,\r\n                    flipY,\r\n                });\r\n                texture.loaded = this.loadImage(gl, src, texture, flipY);\r\n                break;\r\n            default:\r\n                console.warn('No supported format supplied');\r\n                texture = new Texture(gl);\r\n        }\r\n\r\n        texture.ext = ext;\r\n        cache[cacheID] = texture;\r\n        return texture;\r\n    }\r\n\r\n    static getSupportedExtensions(gl) {\r\n        if (supportedExtensions.length) return supportedExtensions;\r\n\r\n        const extensions = {\r\n            pvrtc: gl.renderer.getExtension('WEBGL_compressed_texture_pvrtc') || gl.renderer.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\r\n            s3tc: gl.renderer.getExtension('WEBGL_compressed_texture_s3tc'),\r\n            // etc: gl.renderer.getExtension('WEBGL_compressed_texture_etc'),\r\n            etc1: gl.renderer.getExtension('WEBGL_compressed_texture_etc1'),\r\n            astc: gl.renderer.getExtension('WEBGL_compressed_texture_astc'),\r\n            bc7: gl.renderer.getExtension('EXT_texture_compression_bptc'),\r\n        };\r\n\r\n        for (const ext in extensions) if (extensions[ext]) supportedExtensions.push(ext);\r\n\r\n        // Formats supported by all\r\n        supportedExtensions.push('png', 'jpg', 'webp');\r\n\r\n        return supportedExtensions;\r\n    }\r\n\r\n    static loadKTX(src, texture) {\r\n        return fetch(src)\r\n            .then((res) => res.arrayBuffer())\r\n            .then((buffer) => texture.parseBuffer(buffer));\r\n    }\r\n\r\n    static loadImage(gl, src, texture, flipY) {\r\n        return decodeImage(src, flipY).then((imgBmp) => {\r\n            // Catch non POT textures for WebGL1 and update params to avoid errors\r\n            if (!gl.renderer.isWebgl2 && (!powerOfTwo(imgBmp.width) || !powerOfTwo(imgBmp.height))) {\r\n                if (texture.generateMipmaps) texture.generateMipmaps = false;\r\n                if (texture.minFilter === gl.NEAREST_MIPMAP_LINEAR) texture.minFilter = gl.LINEAR;\r\n                if (texture.wrapS === gl.REPEAT) texture.wrapS = texture.wrapT = gl.CLAMP_TO_EDGE;\r\n            }\r\n\r\n            texture.image = imgBmp;\r\n\r\n            // For createImageBitmap, close once uploaded\r\n            texture.onUpdate = () => {\r\n                if (imgBmp.close) imgBmp.close();\r\n                texture.onUpdate = null;\r\n            };\r\n\r\n            return imgBmp;\r\n        });\r\n    }\r\n\r\n    static clearCache() {\r\n        cache = {};\r\n    }\r\n}\r\n\r\nfunction powerOfTwo(value) {\r\n    // (width & (width - 1)) !== 0\r\n    return Math.log2(value) % 1 === 0;\r\n}\r\n\r\nfunction decodeImage(src, flipY) {\r\n    return new Promise((resolve, reject) => {\r\n        if (isCreateImageBitmap()) {\r\n            fetch(src, { mode: 'cors' })\r\n                .then((r) => r.blob())\r\n                .then((b) => createImageBitmap(b, { imageOrientation: flipY ? 'flipY' : 'none', premultiplyAlpha: 'none' }))\r\n                .then(resolve)\r\n                .catch((err) => reject(err));\r\n        } else {\r\n            const img = new Image();\r\n\r\n            img.crossOrigin = '';\r\n            img.src = src;\r\n            img.onerror = ({ type }) => reject(`${type}: Loading image`);\r\n            img.onload = () => resolve(img);\r\n        }\r\n    });\r\n}\r\n\r\nfunction isCreateImageBitmap() {\r\n    const isChrome = navigator.userAgent.toLowerCase().includes('chrome');\r\n    if (!isChrome) return false;\r\n    try {\r\n        createImageBitmap;\r\n    } catch (e) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}