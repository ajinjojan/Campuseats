{"ast":null,"code":"// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n\n//     buffer - gl buffer, if buffer exists, don't need to provide data - although needs position data for bounds calculation\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n\n// TODO: fit in transform feedback\n\nimport { Vec3 } from '../math/Vec3.js';\nconst tempVec3 = /* @__PURE__ */new Vec3();\nlet ID = 1;\nlet ATTR_ID = 1;\n\n// To stop inifinite warnings\nlet isBoundsWarned = false;\nexport class Geometry {\n  constructor(gl, attributes = {}) {\n    if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\n    this.gl = gl;\n    this.attributes = attributes;\n    this.id = ID++;\n\n    // Store one VAO per program attribute locations order\n    this.VAOs = {};\n    this.drawRange = {\n      start: 0,\n      count: 0\n    };\n    this.instancedCount = 0;\n\n    // Unbind current VAO so that new buffers don't get added to active mesh\n    this.gl.renderer.bindVertexArray(null);\n    this.gl.renderer.currentGeometry = null;\n\n    // Alias for state store to avoid redundant calls for global state\n    this.glState = this.gl.renderer.state;\n\n    // create the buffers\n    for (let key in attributes) {\n      this.addAttribute(key, attributes[key]);\n    }\n  }\n  addAttribute(key, attr) {\n    this.attributes[key] = attr;\n\n    // Set options\n    attr.id = ATTR_ID++; // TODO: currently unused, remove?\n    attr.size = attr.size || 1;\n    attr.type = attr.type || (attr.data.constructor === Float32Array ? this.gl.FLOAT : attr.data.constructor === Uint16Array ? this.gl.UNSIGNED_SHORT : this.gl.UNSIGNED_INT); // Uint32Array\n    attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n    attr.normalized = attr.normalized || false;\n    attr.stride = attr.stride || 0;\n    attr.offset = attr.offset || 0;\n    attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n    attr.divisor = attr.instanced || 0;\n    attr.needsUpdate = false;\n    attr.usage = attr.usage || this.gl.STATIC_DRAW;\n    if (!attr.buffer) {\n      // Push data to buffer\n      this.updateAttribute(attr);\n    }\n\n    // Update geometry counts. If indexed, ignore regular attributes\n    if (attr.divisor) {\n      this.isInstanced = true;\n      if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n        console.warn('geometry has multiple instanced buffers of different length');\n        return this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor);\n      }\n      this.instancedCount = attr.count * attr.divisor;\n    } else if (key === 'index') {\n      this.drawRange.count = attr.count;\n    } else if (!this.attributes.index) {\n      this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n    }\n  }\n  updateAttribute(attr) {\n    const isNewBuffer = !attr.buffer;\n    if (isNewBuffer) attr.buffer = this.gl.createBuffer();\n    if (this.glState.boundBuffer !== attr.buffer) {\n      this.gl.bindBuffer(attr.target, attr.buffer);\n      this.glState.boundBuffer = attr.buffer;\n    }\n    if (isNewBuffer) {\n      this.gl.bufferData(attr.target, attr.data, attr.usage);\n    } else {\n      this.gl.bufferSubData(attr.target, 0, attr.data);\n    }\n    attr.needsUpdate = false;\n  }\n  setIndex(value) {\n    this.addAttribute('index', value);\n  }\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n  setInstancedCount(value) {\n    this.instancedCount = value;\n  }\n  createVAO(program) {\n    this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n    this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n    this.bindAttributes(program);\n  }\n  bindAttributes(program) {\n    // Link all attributes to program using gl.vertexAttribPointer\n    program.attributeLocations.forEach((location, {\n      name,\n      type\n    }) => {\n      // If geometry missing a required shader attribute\n      if (!this.attributes[name]) {\n        console.warn(`active attribute ${name} not being supplied`);\n        return;\n      }\n      const attr = this.attributes[name];\n      this.gl.bindBuffer(attr.target, attr.buffer);\n      this.glState.boundBuffer = attr.buffer;\n\n      // For matrix attributes, buffer needs to be defined per column\n      let numLoc = 1;\n      if (type === 35674) numLoc = 2; // mat2\n      if (type === 35675) numLoc = 3; // mat3\n      if (type === 35676) numLoc = 4; // mat4\n\n      const size = attr.size / numLoc;\n      const stride = numLoc === 1 ? 0 : numLoc * numLoc * 4;\n      const offset = numLoc === 1 ? 0 : numLoc * 4;\n      for (let i = 0; i < numLoc; i++) {\n        this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n        this.gl.enableVertexAttribArray(location + i);\n\n        // For instanced attributes, divisor needs to be set.\n        // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n        this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n      }\n    });\n\n    // Bind indices if geometry indexed\n    if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n  }\n  draw({\n    program,\n    mode = this.gl.TRIANGLES\n  }) {\n    if (this.gl.renderer.currentGeometry !== `${this.id}_${program.attributeOrder}`) {\n      if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n      this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n      this.gl.renderer.currentGeometry = `${this.id}_${program.attributeOrder}`;\n    }\n\n    // Check if any attributes need updating\n    program.attributeLocations.forEach((location, {\n      name\n    }) => {\n      const attr = this.attributes[name];\n      if (attr.needsUpdate) this.updateAttribute(attr);\n    });\n\n    // For drawElements, offset needs to be multiple of type size\n    let indexBytesPerElement = 2;\n    if (this.attributes.index?.type === this.gl.UNSIGNED_INT) indexBytesPerElement = 4;\n    if (this.isInstanced) {\n      if (this.attributes.index) {\n        this.gl.renderer.drawElementsInstanced(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * indexBytesPerElement, this.instancedCount);\n      } else {\n        this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n      }\n    } else {\n      if (this.attributes.index) {\n        this.gl.drawElements(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * indexBytesPerElement);\n      } else {\n        this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n      }\n    }\n  }\n  getPosition() {\n    // Use position buffer, or min/max if available\n    const attr = this.attributes.position;\n    // if (attr.min) return [...attr.min, ...attr.max];\n    if (attr.data) return attr;\n    if (isBoundsWarned) return;\n    console.warn('No position buffer data found to compute bounds');\n    return isBoundsWarned = true;\n  }\n  computeBoundingBox(attr) {\n    if (!attr) attr = this.getPosition();\n    const array = attr.data;\n    // Data loaded shouldn't haave stride, only buffers\n    // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n    const stride = attr.size;\n    if (!this.bounds) {\n      this.bounds = {\n        min: new Vec3(),\n        max: new Vec3(),\n        center: new Vec3(),\n        scale: new Vec3(),\n        radius: Infinity\n      };\n    }\n    const min = this.bounds.min;\n    const max = this.bounds.max;\n    const center = this.bounds.center;\n    const scale = this.bounds.scale;\n    min.set(+Infinity);\n    max.set(-Infinity);\n\n    // TODO: check size of position (eg triangle with Vec2)\n    for (let i = 0, l = array.length; i < l; i += stride) {\n      const x = array[i];\n      const y = array[i + 1];\n      const z = array[i + 2];\n      min.x = Math.min(x, min.x);\n      min.y = Math.min(y, min.y);\n      min.z = Math.min(z, min.z);\n      max.x = Math.max(x, max.x);\n      max.y = Math.max(y, max.y);\n      max.z = Math.max(z, max.z);\n    }\n    scale.sub(max, min);\n    center.add(min, max).divide(2);\n  }\n  computeBoundingSphere(attr) {\n    if (!attr) attr = this.getPosition();\n    const array = attr.data;\n    // Data loaded shouldn't haave stride, only buffers\n    // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n    const stride = attr.size;\n    if (!this.bounds) this.computeBoundingBox(attr);\n    let maxRadiusSq = 0;\n    for (let i = 0, l = array.length; i < l; i += stride) {\n      tempVec3.fromArray(array, i);\n      maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n    }\n    this.bounds.radius = Math.sqrt(maxRadiusSq);\n  }\n  remove() {\n    for (let key in this.VAOs) {\n      this.gl.renderer.deleteVertexArray(this.VAOs[key]);\n      delete this.VAOs[key];\n    }\n    for (let key in this.attributes) {\n      this.gl.deleteBuffer(this.attributes[key].buffer);\n      delete this.attributes[key];\n    }\n  }\n}","map":{"version":3,"names":["Vec3","tempVec3","ID","ATTR_ID","isBoundsWarned","Geometry","constructor","gl","attributes","canvas","console","error","id","VAOs","drawRange","start","count","instancedCount","renderer","bindVertexArray","currentGeometry","glState","state","key","addAttribute","attr","size","type","data","Float32Array","FLOAT","Uint16Array","UNSIGNED_SHORT","UNSIGNED_INT","target","ELEMENT_ARRAY_BUFFER","ARRAY_BUFFER","normalized","stride","offset","byteLength","length","divisor","instanced","needsUpdate","usage","STATIC_DRAW","buffer","updateAttribute","isInstanced","warn","Math","min","index","max","isNewBuffer","createBuffer","boundBuffer","bindBuffer","bufferData","bufferSubData","setIndex","value","setDrawRange","setInstancedCount","createVAO","program","attributeOrder","createVertexArray","bindAttributes","attributeLocations","forEach","location","name","numLoc","i","vertexAttribPointer","enableVertexAttribArray","vertexAttribDivisor","draw","mode","TRIANGLES","indexBytesPerElement","drawElementsInstanced","drawArraysInstanced","drawElements","drawArrays","getPosition","position","computeBoundingBox","array","bounds","center","scale","radius","Infinity","set","l","x","y","z","sub","add","divide","computeBoundingSphere","maxRadiusSq","fromArray","squaredDistance","sqrt","remove","deleteVertexArray","deleteBuffer"],"sources":["C:/Users/dudet/Documents/gitexp/CampusEats/node_modules/ogl/src/core/Geometry.js"],"sourcesContent":["// attribute params\r\n// {\r\n//     data - typed array eg UInt16Array for indices, Float32Array\r\n//     size - int default 1\r\n//     instanced - default null. Pass divisor amount\r\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\r\n//     normalized - boolean default false\r\n\r\n//     buffer - gl buffer, if buffer exists, don't need to provide data - although needs position data for bounds calculation\r\n//     stride - default 0 - for when passing in buffer\r\n//     offset - default 0 - for when passing in buffer\r\n//     count - default null - for when passing in buffer\r\n//     min - array - for when passing in buffer\r\n//     max - array - for when passing in buffer\r\n// }\r\n\r\n// TODO: fit in transform feedback\r\n\r\nimport { Vec3 } from '../math/Vec3.js';\r\n\r\nconst tempVec3 = /* @__PURE__ */ new Vec3();\r\n\r\nlet ID = 1;\r\nlet ATTR_ID = 1;\r\n\r\n// To stop inifinite warnings\r\nlet isBoundsWarned = false;\r\n\r\nexport class Geometry {\r\n    constructor(gl, attributes = {}) {\r\n        if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\r\n        this.gl = gl;\r\n        this.attributes = attributes;\r\n        this.id = ID++;\r\n\r\n        // Store one VAO per program attribute locations order\r\n        this.VAOs = {};\r\n\r\n        this.drawRange = { start: 0, count: 0 };\r\n        this.instancedCount = 0;\r\n\r\n        // Unbind current VAO so that new buffers don't get added to active mesh\r\n        this.gl.renderer.bindVertexArray(null);\r\n        this.gl.renderer.currentGeometry = null;\r\n\r\n        // Alias for state store to avoid redundant calls for global state\r\n        this.glState = this.gl.renderer.state;\r\n\r\n        // create the buffers\r\n        for (let key in attributes) {\r\n            this.addAttribute(key, attributes[key]);\r\n        }\r\n    }\r\n\r\n    addAttribute(key, attr) {\r\n        this.attributes[key] = attr;\r\n\r\n        // Set options\r\n        attr.id = ATTR_ID++; // TODO: currently unused, remove?\r\n        attr.size = attr.size || 1;\r\n        attr.type =\r\n            attr.type ||\r\n            (attr.data.constructor === Float32Array\r\n                ? this.gl.FLOAT\r\n                : attr.data.constructor === Uint16Array\r\n                ? this.gl.UNSIGNED_SHORT\r\n                : this.gl.UNSIGNED_INT); // Uint32Array\r\n        attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\r\n        attr.normalized = attr.normalized || false;\r\n        attr.stride = attr.stride || 0;\r\n        attr.offset = attr.offset || 0;\r\n        attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\r\n        attr.divisor = attr.instanced || 0;\r\n        attr.needsUpdate = false;\r\n        attr.usage = attr.usage || this.gl.STATIC_DRAW;\r\n\r\n        if (!attr.buffer) {\r\n            // Push data to buffer\r\n            this.updateAttribute(attr);\r\n        }\r\n\r\n        // Update geometry counts. If indexed, ignore regular attributes\r\n        if (attr.divisor) {\r\n            this.isInstanced = true;\r\n            if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\r\n                console.warn('geometry has multiple instanced buffers of different length');\r\n                return (this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor));\r\n            }\r\n            this.instancedCount = attr.count * attr.divisor;\r\n        } else if (key === 'index') {\r\n            this.drawRange.count = attr.count;\r\n        } else if (!this.attributes.index) {\r\n            this.drawRange.count = Math.max(this.drawRange.count, attr.count);\r\n        }\r\n    }\r\n\r\n    updateAttribute(attr) {\r\n        const isNewBuffer = !attr.buffer;\r\n        if (isNewBuffer) attr.buffer = this.gl.createBuffer();\r\n        if (this.glState.boundBuffer !== attr.buffer) {\r\n            this.gl.bindBuffer(attr.target, attr.buffer);\r\n            this.glState.boundBuffer = attr.buffer;\r\n        }\r\n        if (isNewBuffer) {\r\n            this.gl.bufferData(attr.target, attr.data, attr.usage);\r\n        } else {\r\n            this.gl.bufferSubData(attr.target, 0, attr.data);\r\n        }\r\n        attr.needsUpdate = false;\r\n    }\r\n\r\n    setIndex(value) {\r\n        this.addAttribute('index', value);\r\n    }\r\n\r\n    setDrawRange(start, count) {\r\n        this.drawRange.start = start;\r\n        this.drawRange.count = count;\r\n    }\r\n\r\n    setInstancedCount(value) {\r\n        this.instancedCount = value;\r\n    }\r\n\r\n    createVAO(program) {\r\n        this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\r\n        this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\r\n        this.bindAttributes(program);\r\n    }\r\n\r\n    bindAttributes(program) {\r\n        // Link all attributes to program using gl.vertexAttribPointer\r\n        program.attributeLocations.forEach((location, { name, type }) => {\r\n            // If geometry missing a required shader attribute\r\n            if (!this.attributes[name]) {\r\n                console.warn(`active attribute ${name} not being supplied`);\r\n                return;\r\n            }\r\n\r\n            const attr = this.attributes[name];\r\n\r\n            this.gl.bindBuffer(attr.target, attr.buffer);\r\n            this.glState.boundBuffer = attr.buffer;\r\n\r\n            // For matrix attributes, buffer needs to be defined per column\r\n            let numLoc = 1;\r\n            if (type === 35674) numLoc = 2; // mat2\r\n            if (type === 35675) numLoc = 3; // mat3\r\n            if (type === 35676) numLoc = 4; // mat4\r\n\r\n            const size = attr.size / numLoc;\r\n            const stride = numLoc === 1 ? 0 : numLoc * numLoc * 4;\r\n            const offset = numLoc === 1 ? 0 : numLoc * 4;\r\n\r\n            for (let i = 0; i < numLoc; i++) {\r\n                this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\r\n                this.gl.enableVertexAttribArray(location + i);\r\n\r\n                // For instanced attributes, divisor needs to be set.\r\n                // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\r\n                this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\r\n            }\r\n        });\r\n\r\n        // Bind indices if geometry indexed\r\n        if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\r\n    }\r\n\r\n    draw({ program, mode = this.gl.TRIANGLES }) {\r\n        if (this.gl.renderer.currentGeometry !== `${this.id}_${program.attributeOrder}`) {\r\n            if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\r\n            this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\r\n            this.gl.renderer.currentGeometry = `${this.id}_${program.attributeOrder}`;\r\n        }\r\n\r\n        // Check if any attributes need updating\r\n        program.attributeLocations.forEach((location, { name }) => {\r\n            const attr = this.attributes[name];\r\n            if (attr.needsUpdate) this.updateAttribute(attr);\r\n        });\r\n\r\n        // For drawElements, offset needs to be multiple of type size\r\n        let indexBytesPerElement = 2;\r\n        if (this.attributes.index?.type === this.gl.UNSIGNED_INT) indexBytesPerElement = 4;\r\n\r\n        if (this.isInstanced) {\r\n            if (this.attributes.index) {\r\n                this.gl.renderer.drawElementsInstanced(\r\n                    mode,\r\n                    this.drawRange.count,\r\n                    this.attributes.index.type,\r\n                    this.attributes.index.offset + this.drawRange.start * indexBytesPerElement,\r\n                    this.instancedCount\r\n                );\r\n            } else {\r\n                this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\r\n            }\r\n        } else {\r\n            if (this.attributes.index) {\r\n                this.gl.drawElements(\r\n                    mode,\r\n                    this.drawRange.count,\r\n                    this.attributes.index.type,\r\n                    this.attributes.index.offset + this.drawRange.start * indexBytesPerElement\r\n                );\r\n            } else {\r\n                this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\r\n            }\r\n        }\r\n    }\r\n\r\n    getPosition() {\r\n        // Use position buffer, or min/max if available\r\n        const attr = this.attributes.position;\r\n        // if (attr.min) return [...attr.min, ...attr.max];\r\n        if (attr.data) return attr;\r\n        if (isBoundsWarned) return;\r\n        console.warn('No position buffer data found to compute bounds');\r\n        return (isBoundsWarned = true);\r\n    }\r\n\r\n    computeBoundingBox(attr) {\r\n        if (!attr) attr = this.getPosition();\r\n        const array = attr.data;\r\n        // Data loaded shouldn't haave stride, only buffers\r\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\r\n        const stride = attr.size;\r\n\r\n        if (!this.bounds) {\r\n            this.bounds = {\r\n                min: new Vec3(),\r\n                max: new Vec3(),\r\n                center: new Vec3(),\r\n                scale: new Vec3(),\r\n                radius: Infinity,\r\n            };\r\n        }\r\n\r\n        const min = this.bounds.min;\r\n        const max = this.bounds.max;\r\n        const center = this.bounds.center;\r\n        const scale = this.bounds.scale;\r\n\r\n        min.set(+Infinity);\r\n        max.set(-Infinity);\r\n\r\n        // TODO: check size of position (eg triangle with Vec2)\r\n        for (let i = 0, l = array.length; i < l; i += stride) {\r\n            const x = array[i];\r\n            const y = array[i + 1];\r\n            const z = array[i + 2];\r\n\r\n            min.x = Math.min(x, min.x);\r\n            min.y = Math.min(y, min.y);\r\n            min.z = Math.min(z, min.z);\r\n\r\n            max.x = Math.max(x, max.x);\r\n            max.y = Math.max(y, max.y);\r\n            max.z = Math.max(z, max.z);\r\n        }\r\n\r\n        scale.sub(max, min);\r\n        center.add(min, max).divide(2);\r\n    }\r\n\r\n    computeBoundingSphere(attr) {\r\n        if (!attr) attr = this.getPosition();\r\n        const array = attr.data;\r\n        // Data loaded shouldn't haave stride, only buffers\r\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\r\n        const stride = attr.size;\r\n\r\n        if (!this.bounds) this.computeBoundingBox(attr);\r\n\r\n        let maxRadiusSq = 0;\r\n        for (let i = 0, l = array.length; i < l; i += stride) {\r\n            tempVec3.fromArray(array, i);\r\n            maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\r\n        }\r\n\r\n        this.bounds.radius = Math.sqrt(maxRadiusSq);\r\n    }\r\n\r\n    remove() {\r\n        for (let key in this.VAOs) {\r\n            this.gl.renderer.deleteVertexArray(this.VAOs[key]);\r\n            delete this.VAOs[key];\r\n        }\r\n        for (let key in this.attributes) {\r\n            this.gl.deleteBuffer(this.attributes[key].buffer);\r\n            delete this.attributes[key];\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}