{"ast":null,"code":"'use strict';\n\n/**\r\n *\r\n * This class allows the manipulation of complex numbers.\r\n * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.\r\n *\r\n * Object form\r\n * { re: <real>, im: <imaginary> }\r\n * { arg: <angle>, abs: <radius> }\r\n * { phi: <angle>, r: <radius> }\r\n *\r\n * Array / Vector form\r\n * [ real, imaginary ]\r\n *\r\n * Double form\r\n * 99.3 - Single double value\r\n *\r\n * String form\r\n * '23.1337' - Simple real number\r\n * '15+3i' - a simple complex number\r\n * '3-i' - a simple complex number\r\n *\r\n * Example:\r\n *\r\n * const c = new Complex('99.3+8i');\r\n * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);\r\n *\r\n */\nconst cosh = Math.cosh || function (x) {\n  return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;\n};\nconst sinh = Math.sinh || function (x) {\n  return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;\n};\n\n/**\r\n * Calculates cos(x) - 1 using Taylor series if x is small (-¼π ≤ x ≤ ¼π).\r\n *\r\n * @param {number} x\r\n * @returns {number} cos(x) - 1\r\n */\nconst cosm1 = x => {\n  // cos(x) - 1 = − 2sin^2(x / 2)\n  const s = Math.sin(0.5 * x);\n  return -2 * s * s;\n};\nconst hypot = function (x, y) {\n  x = Math.abs(x);\n  y = Math.abs(y);\n\n  // Ensure `x` is the larger value\n  if (x < y) [x, y] = [y, x];\n\n  // If both are below the threshold, use straightforward Pythagoras\n  if (x < 1e8) return Math.sqrt(x * x + y * y);\n\n  // For larger values, scale to avoid overflow\n  y /= x;\n  return x * Math.sqrt(1 + y * y);\n};\nconst parser_exit = function () {\n  throw SyntaxError('Invalid Param');\n};\n\n/**\r\n * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows\r\n *\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number}\r\n */\nfunction logHypot(a, b) {\n  const _a = Math.abs(a);\n  const _b = Math.abs(b);\n  if (a === 0) {\n    return Math.log(_b);\n  }\n  if (b === 0) {\n    return Math.log(_a);\n  }\n  if (_a < 3000 && _b < 3000) {\n    return Math.log(a * a + b * b) * 0.5;\n  }\n\n  /* I got 4 ideas to compute this property without overflow:\r\n   *\r\n   * Testing 1000000 times with random samples for a,b ∈ [1, 1000000000] against a big decimal library to get an error estimate\r\n   *\r\n   * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)\r\n     Math.log(a * a + b * b) / 2\r\n     *\r\n   *\r\n   * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)\r\n     const fn = function(a, b) {\r\n   a = Math.abs(a);\r\n   b = Math.abs(b);\r\n   let t = Math.min(a, b);\r\n   a = Math.max(a, b);\r\n   t = t / a;\r\n     return Math.log(a) + Math.log(1 + t * t) / 2;\r\n   };\r\n     * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)\r\n     Math.log(a / Math.cos(Math.atan2(b, a)))\r\n     * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)\r\n     Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))\r\n     */\n\n  a = a * 0.5;\n  b = b * 0.5;\n  return 0.5 * Math.log(a * a + b * b) + Math.LN2;\n}\nconst P = {\n  're': 0,\n  'im': 0\n};\nconst parse = function (a, b) {\n  const z = P;\n  if (a === undefined || a === null) {\n    z['re'] = z['im'] = 0;\n  } else if (b !== undefined) {\n    z['re'] = a;\n    z['im'] = b;\n  } else switch (typeof a) {\n    case 'object':\n      if ('im' in a && 're' in a) {\n        z['re'] = a['re'];\n        z['im'] = a['im'];\n      } else if ('abs' in a && 'arg' in a) {\n        if (!isFinite(a['abs']) && isFinite(a['arg'])) {\n          return Complex['INFINITY'];\n        }\n        z['re'] = a['abs'] * Math.cos(a['arg']);\n        z['im'] = a['abs'] * Math.sin(a['arg']);\n      } else if ('r' in a && 'phi' in a) {\n        if (!isFinite(a['r']) && isFinite(a['phi'])) {\n          return Complex['INFINITY'];\n        }\n        z['re'] = a['r'] * Math.cos(a['phi']);\n        z['im'] = a['r'] * Math.sin(a['phi']);\n      } else if (a.length === 2) {\n        // Quick array check\n        z['re'] = a[0];\n        z['im'] = a[1];\n      } else {\n        parser_exit();\n      }\n      break;\n    case 'string':\n      z['im'] = /* void */\n      z['re'] = 0;\n      const tokens = a.replace(/_/g, '').match(/\\d+\\.?\\d*e[+-]?\\d+|\\d+\\.?\\d*|\\.\\d+|./g);\n      let plus = 1;\n      let minus = 0;\n      if (tokens === null) {\n        parser_exit();\n      }\n      for (let i = 0; i < tokens.length; i++) {\n        const c = tokens[i];\n        if (c === ' ' || c === '\\t' || c === '\\n') {\n          /* void */\n        } else if (c === '+') {\n          plus++;\n        } else if (c === '-') {\n          minus++;\n        } else if (c === 'i' || c === 'I') {\n          if (plus + minus === 0) {\n            parser_exit();\n          }\n          if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {\n            z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);\n            i++;\n          } else {\n            z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');\n          }\n          plus = minus = 0;\n        } else {\n          if (plus + minus === 0 || isNaN(c)) {\n            parser_exit();\n          }\n          if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {\n            z['im'] += parseFloat((minus % 2 ? '-' : '') + c);\n            i++;\n          } else {\n            z['re'] += parseFloat((minus % 2 ? '-' : '') + c);\n          }\n          plus = minus = 0;\n        }\n      }\n\n      // Still something on the stack\n      if (plus + minus > 0) {\n        parser_exit();\n      }\n      break;\n    case 'number':\n      z['im'] = 0;\n      z['re'] = a;\n      break;\n    default:\n      parser_exit();\n  }\n  if (isNaN(z['re']) || isNaN(z['im'])) {\n    // If a calculation is NaN, we treat it as NaN and don't throw\n    //parser_exit();\n  }\n  return z;\n};\n\n/**\r\n * @constructor\r\n * @returns {Complex}\r\n */\nfunction Complex(a, b) {\n  if (!(this instanceof Complex)) {\n    return new Complex(a, b);\n  }\n  const z = parse(a, b);\n  this['re'] = z['re'];\n  this['im'] = z['im'];\n}\nComplex.prototype = {\n  're': 0,\n  'im': 0,\n  /**\r\n   * Calculates the sign of a complex number, which is a normalized complex\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'sign': function () {\n    const abs = hypot(this['re'], this['im']);\n    return new Complex(this['re'] / abs, this['im'] / abs);\n  },\n  /**\r\n   * Adds two complex numbers\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'add': function (a, b) {\n    const z = parse(a, b);\n    const tInfin = this['isInfinite']();\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\n    if (tInfin || zInfin) {\n      if (tInfin && zInfin) {\n        // Infinity + Infinity = NaN\n        return Complex['NAN'];\n      }\n      // Infinity + z = Infinity { where z != Infinity }\n      return Complex['INFINITY'];\n    }\n    return new Complex(this['re'] + z['re'], this['im'] + z['im']);\n  },\n  /**\r\n   * Subtracts two complex numbers\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'sub': function (a, b) {\n    const z = parse(a, b);\n    const tInfin = this['isInfinite']();\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\n    if (tInfin || zInfin) {\n      if (tInfin && zInfin) {\n        // Infinity - Infinity = NaN\n        return Complex['NAN'];\n      }\n      // Infinity - z = Infinity { where z != Infinity }\n      return Complex['INFINITY'];\n    }\n    return new Complex(this['re'] - z['re'], this['im'] - z['im']);\n  },\n  /**\r\n   * Multiplies two complex numbers\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'mul': function (a, b) {\n    const z = parse(a, b);\n    const tInfin = this['isInfinite']();\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\n    const tIsZero = this['re'] === 0 && this['im'] === 0;\n    const zIsZero = z['re'] === 0 && z['im'] === 0;\n\n    // Infinity * 0 = NaN\n    if (tInfin && zIsZero || zInfin && tIsZero) {\n      return Complex['NAN'];\n    }\n\n    // Infinity * z = Infinity { where z != 0 }\n    if (tInfin || zInfin) {\n      return Complex['INFINITY'];\n    }\n\n    // Shortcut for real values\n    if (z['im'] === 0 && this['im'] === 0) {\n      return new Complex(this['re'] * z['re'], 0);\n    }\n    return new Complex(this['re'] * z['re'] - this['im'] * z['im'], this['re'] * z['im'] + this['im'] * z['re']);\n  },\n  /**\r\n   * Divides two complex numbers\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'div': function (a, b) {\n    const z = parse(a, b);\n    const tInfin = this['isInfinite']();\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\n    const tIsZero = this['re'] === 0 && this['im'] === 0;\n    const zIsZero = z['re'] === 0 && z['im'] === 0;\n\n    // 0 / 0 = NaN and Infinity / Infinity = NaN\n    if (tIsZero && zIsZero || tInfin && zInfin) {\n      return Complex['NAN'];\n    }\n\n    // Infinity / 0 = Infinity\n    if (zIsZero || tInfin) {\n      return Complex['INFINITY'];\n    }\n\n    // 0 / Infinity = 0\n    if (tIsZero || zInfin) {\n      return Complex['ZERO'];\n    }\n    if (0 === z['im']) {\n      // Divisor is real\n      return new Complex(this['re'] / z['re'], this['im'] / z['re']);\n    }\n    if (Math.abs(z['re']) < Math.abs(z['im'])) {\n      const x = z['re'] / z['im'];\n      const t = z['re'] * x + z['im'];\n      return new Complex((this['re'] * x + this['im']) / t, (this['im'] * x - this['re']) / t);\n    } else {\n      const x = z['im'] / z['re'];\n      const t = z['im'] * x + z['re'];\n      return new Complex((this['re'] + this['im'] * x) / t, (this['im'] - this['re'] * x) / t);\n    }\n  },\n  /**\r\n   * Calculate the power of two complex numbers\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'pow': function (a, b) {\n    const z = parse(a, b);\n    const tIsZero = this['re'] === 0 && this['im'] === 0;\n    const zIsZero = z['re'] === 0 && z['im'] === 0;\n    if (zIsZero) {\n      return Complex['ONE'];\n    }\n\n    // If the exponent is real\n    if (z['im'] === 0) {\n      if (this['im'] === 0 && this['re'] > 0) {\n        return new Complex(Math.pow(this['re'], z['re']), 0);\n      } else if (this['re'] === 0) {\n        // If base is fully imaginary\n\n        switch ((z['re'] % 4 + 4) % 4) {\n          case 0:\n            return new Complex(Math.pow(this['im'], z['re']), 0);\n          case 1:\n            return new Complex(0, Math.pow(this['im'], z['re']));\n          case 2:\n            return new Complex(-Math.pow(this['im'], z['re']), 0);\n          case 3:\n            return new Complex(0, -Math.pow(this['im'], z['re']));\n        }\n      }\n    }\n\n    /* I couldn't find a good formula, so here is a derivation and optimization\r\n     *\r\n     * z_1^z_2 = (a + bi)^(c + di)\r\n     *         = exp((c + di) * log(a + bi)\r\n     *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))\r\n     * =>...\r\n     * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\r\n     * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\r\n     *\r\n     * =>...\r\n     * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\r\n     * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\r\n     *\r\n     * =>\r\n     * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))\r\n     * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))\r\n     *\r\n     */\n\n    if (tIsZero && z['re'] > 0) {\n      // Same behavior as Wolframalpha, Zero if real part is zero\n      return Complex['ZERO'];\n    }\n    const arg = Math.atan2(this['im'], this['re']);\n    const loh = logHypot(this['re'], this['im']);\n    let re = Math.exp(z['re'] * loh - z['im'] * arg);\n    let im = z['im'] * loh + z['re'] * arg;\n    return new Complex(re * Math.cos(im), re * Math.sin(im));\n  },\n  /**\r\n   * Calculate the complex square root\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'sqrt': function () {\n    const a = this['re'];\n    const b = this['im'];\n    if (b === 0) {\n      // Real number case\n      if (a >= 0) {\n        return new Complex(Math.sqrt(a), 0);\n      } else {\n        return new Complex(0, Math.sqrt(-a));\n      }\n    }\n    const r = hypot(a, b);\n    let re = Math.sqrt(0.5 * (r + Math.abs(a))); // sqrt(2x) / 2 = sqrt(x / 2)\n    let im = Math.abs(b) / (2 * re);\n    if (a >= 0) {\n      return new Complex(re, b < 0 ? -im : im);\n    } else {\n      return new Complex(im, b < 0 ? -re : re);\n    }\n  },\n  /**\r\n   * Calculate the complex exponent\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'exp': function () {\n    const er = Math.exp(this['re']);\n    if (this['im'] === 0) {\n      return new Complex(er, 0);\n    }\n    return new Complex(er * Math.cos(this['im']), er * Math.sin(this['im']));\n  },\n  /**\r\n   * Calculate the complex exponent and subtracts one.\r\n   *\r\n   * This may be more accurate than `Complex(x).exp().sub(1)` if\r\n   * `x` is small.\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'expm1': function () {\n    /**\r\n     * exp(a + i*b) - 1\r\n     = exp(a) * (cos(b) + j*sin(b)) - 1\r\n     = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)\r\n     */\n\n    const a = this['re'];\n    const b = this['im'];\n    return new Complex(Math.expm1(a) * Math.cos(b) + cosm1(b), Math.exp(a) * Math.sin(b));\n  },\n  /**\r\n   * Calculate the natural log\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'log': function () {\n    const a = this['re'];\n    const b = this['im'];\n    if (b === 0 && a > 0) {\n      return new Complex(Math.log(a), 0);\n    }\n    return new Complex(logHypot(a, b), Math.atan2(b, a));\n  },\n  /**\r\n   * Calculate the magnitude of the complex number\r\n   *\r\n   * @returns {number}\r\n   */\n  'abs': function () {\n    return hypot(this['re'], this['im']);\n  },\n  /**\r\n   * Calculate the angle of the complex number\r\n   *\r\n   * @returns {number}\r\n   */\n  'arg': function () {\n    return Math.atan2(this['im'], this['re']);\n  },\n  /**\r\n   * Calculate the sine of the complex number\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'sin': function () {\n    // sin(z) = ( e^iz - e^-iz ) / 2i \n    //        = sin(a)cosh(b) + i cos(a)sinh(b)\n\n    const a = this['re'];\n    const b = this['im'];\n    return new Complex(Math.sin(a) * cosh(b), Math.cos(a) * sinh(b));\n  },\n  /**\r\n   * Calculate the cosine\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'cos': function () {\n    // cos(z) = ( e^iz + e^-iz ) / 2 \n    //        = cos(a)cosh(b) - i sin(a)sinh(b)\n\n    const a = this['re'];\n    const b = this['im'];\n    return new Complex(Math.cos(a) * cosh(b), -Math.sin(a) * sinh(b));\n  },\n  /**\r\n   * Calculate the tangent\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'tan': function () {\n    // tan(z) = sin(z) / cos(z) \n    //        = ( e^iz - e^-iz ) / ( i( e^iz + e^-iz ) )\n    //        = ( e^2iz - 1 ) / i( e^2iz + 1 )\n    //        = ( sin(2a) + i sinh(2b) ) / ( cos(2a) + cosh(2b) )\n\n    const a = 2 * this['re'];\n    const b = 2 * this['im'];\n    const d = Math.cos(a) + cosh(b);\n    return new Complex(Math.sin(a) / d, sinh(b) / d);\n  },\n  /**\r\n   * Calculate the cotangent\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'cot': function () {\n    // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))\n\n    const a = 2 * this['re'];\n    const b = 2 * this['im'];\n    const d = Math.cos(a) - cosh(b);\n    return new Complex(-Math.sin(a) / d, sinh(b) / d);\n  },\n  /**\r\n   * Calculate the secant\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'sec': function () {\n    // sec(c) = 2 / (e^(ci) + e^(-ci))\n\n    const a = this['re'];\n    const b = this['im'];\n    const d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);\n    return new Complex(Math.cos(a) * cosh(b) / d, Math.sin(a) * sinh(b) / d);\n  },\n  /**\r\n   * Calculate the cosecans\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'csc': function () {\n    // csc(c) = 2i / (e^(ci) - e^(-ci))\n\n    const a = this['re'];\n    const b = this['im'];\n    const d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);\n    return new Complex(Math.sin(a) * cosh(b) / d, -Math.cos(a) * sinh(b) / d);\n  },\n  /**\r\n   * Calculate the complex arcus sinus\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'asin': function () {\n    // asin(c) = -i * log(ci + sqrt(1 - c^2))\n\n    const a = this['re'];\n    const b = this['im'];\n    const t1 = new Complex(b * b - a * a + 1, -2 * a * b)['sqrt']();\n    const t2 = new Complex(t1['re'] - b, t1['im'] + a)['log']();\n    return new Complex(t2['im'], -t2['re']);\n  },\n  /**\r\n   * Calculate the complex arcus cosinus\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'acos': function () {\n    // acos(c) = i * log(c - i * sqrt(1 - c^2))\n\n    const a = this['re'];\n    const b = this['im'];\n    const t1 = new Complex(b * b - a * a + 1, -2 * a * b)['sqrt']();\n    const t2 = new Complex(t1['re'] - b, t1['im'] + a)['log']();\n    return new Complex(Math.PI / 2 - t2['im'], t2['re']);\n  },\n  /**\r\n   * Calculate the complex arcus tangent\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'atan': function () {\n    // atan(c) = i / 2 log((i + x) / (i - x))\n\n    const a = this['re'];\n    const b = this['im'];\n    if (a === 0) {\n      if (b === 1) {\n        return new Complex(0, Infinity);\n      }\n      if (b === -1) {\n        return new Complex(0, -Infinity);\n      }\n    }\n    const d = a * a + (1.0 - b) * (1.0 - b);\n    const t1 = new Complex((1 - b * b - a * a) / d, -2 * a / d).log();\n    return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);\n  },\n  /**\r\n   * Calculate the complex arcus cotangent\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'acot': function () {\n    // acot(c) = i / 2 log((c - i) / (c + i))\n\n    const a = this['re'];\n    const b = this['im'];\n    if (b === 0) {\n      return new Complex(Math.atan2(1, a), 0);\n    }\n    const d = a * a + b * b;\n    return d !== 0 ? new Complex(a / d, -b / d).atan() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).atan();\n  },\n  /**\r\n   * Calculate the complex arcus secant\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'asec': function () {\n    // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))\n\n    const a = this['re'];\n    const b = this['im'];\n    if (a === 0 && b === 0) {\n      return new Complex(0, Infinity);\n    }\n    const d = a * a + b * b;\n    return d !== 0 ? new Complex(a / d, -b / d).acos() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).acos();\n  },\n  /**\r\n   * Calculate the complex arcus cosecans\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'acsc': function () {\n    // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))\n\n    const a = this['re'];\n    const b = this['im'];\n    if (a === 0 && b === 0) {\n      return new Complex(Math.PI / 2, Infinity);\n    }\n    const d = a * a + b * b;\n    return d !== 0 ? new Complex(a / d, -b / d).asin() : new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0).asin();\n  },\n  /**\r\n   * Calculate the complex sinh\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'sinh': function () {\n    // sinh(c) = (e^c - e^-c) / 2\n\n    const a = this['re'];\n    const b = this['im'];\n    return new Complex(sinh(a) * Math.cos(b), cosh(a) * Math.sin(b));\n  },\n  /**\r\n   * Calculate the complex cosh\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'cosh': function () {\n    // cosh(c) = (e^c + e^-c) / 2\n\n    const a = this['re'];\n    const b = this['im'];\n    return new Complex(cosh(a) * Math.cos(b), sinh(a) * Math.sin(b));\n  },\n  /**\r\n   * Calculate the complex tanh\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'tanh': function () {\n    // tanh(c) = (e^c - e^-c) / (e^c + e^-c)\n\n    const a = 2 * this['re'];\n    const b = 2 * this['im'];\n    const d = cosh(a) + Math.cos(b);\n    return new Complex(sinh(a) / d, Math.sin(b) / d);\n  },\n  /**\r\n   * Calculate the complex coth\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'coth': function () {\n    // coth(c) = (e^c + e^-c) / (e^c - e^-c)\n\n    const a = 2 * this['re'];\n    const b = 2 * this['im'];\n    const d = cosh(a) - Math.cos(b);\n    return new Complex(sinh(a) / d, -Math.sin(b) / d);\n  },\n  /**\r\n   * Calculate the complex csch\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'csch': function () {\n    // csch(c) = 2 / (e^c - e^-c)\n\n    const a = this['re'];\n    const b = this['im'];\n    const d = Math.cos(2 * b) - cosh(2 * a);\n    return new Complex(-2 * sinh(a) * Math.cos(b) / d, 2 * cosh(a) * Math.sin(b) / d);\n  },\n  /**\r\n   * Calculate the complex sech\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'sech': function () {\n    // sech(c) = 2 / (e^c + e^-c)\n\n    const a = this['re'];\n    const b = this['im'];\n    const d = Math.cos(2 * b) + cosh(2 * a);\n    return new Complex(2 * cosh(a) * Math.cos(b) / d, -2 * sinh(a) * Math.sin(b) / d);\n  },\n  /**\r\n   * Calculate the complex asinh\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'asinh': function () {\n    // asinh(z) = log(z + sqrt(z^2 + 1))\n\n    const a = this['re'];\n    const b = this['im'];\n    if (b === 0) {\n      if (a === 0) {\n        return new Complex(0, 0);\n      }\n\n      // Use |a| to keep asinh(-a) = -asinh(a) and avoid cancellation for large -a\n      const x = Math.abs(a);\n      const r = Math.log(x + Math.sqrt(x * x + 1));\n      return new Complex(a < 0 ? -r : r, 0);\n    }\n\n    // z^2 + 1 = (a^2 - b^2 + 1) + i (2ab)\n    const re2 = a * a - b * b + 1;\n    const im2 = 2 * a * b;\n    const t = new Complex(re2, im2)['sqrt'](); // sqrt(z^2 + 1)\n\n    return new Complex(a + t['re'], b + t['im'])['log']();\n  },\n  /**\r\n   * Calculate the complex acosh\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'acosh': function () {\n    // acosh(z)= log(z + sqrt(z^2 - 1)) = log(z + sqrt(z - 1) * sqrt(z + 1))\n\n    const a = this['re'];\n    const b = this['im'];\n    if (b === 0) {\n      // z = a is real\n      if (a > 1) {\n        // acosh(a) = log(a + sqrt(a - 1) * sqrt(a + 1)),  a > 1\n        return new Complex(Math.log(a + Math.sqrt(a - 1) * Math.sqrt(a + 1)), 0);\n      }\n      if (a < -1) {\n        // acosh(a) = log(-a + sqrt(a^2 - 1)) + i*pi,  a < -1\n        const t = Math.sqrt(a * a - 1);\n        return new Complex(Math.log(-a + t), Math.PI);\n      }\n\n      // -1 <= a <= 1 : purely imaginary\n      // acosh(a) = i * acos(a)\n      return new Complex(0, Math.acos(a));\n    }\n    const t1 = new Complex(a - 1, b)['sqrt'](); // sqrt(z - 1)\n    const t2 = new Complex(a + 1, b)['sqrt'](); // sqrt(z + 1)\n\n    return new Complex(a + t1['re'] * t2['re'] - t1['im'] * t2['im'], b + t1['re'] * t2['im'] + t1['im'] * t2['re'])['log']();\n  },\n  /**\r\n   * Calculate the complex atanh\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'atanh': function () {\n    // atanh(z) = log((1 + z) / (1 - z)) / 2\n\n    const a = this['re'];\n    const b = this['im'];\n    if (b === 0) {\n      if (a === 0) {\n        return new Complex(0, 0);\n      }\n      if (a === 1) {\n        // limit x -> 1^- atanh(x) = +Infinity\n        return new Complex(Infinity, 0);\n      }\n      if (a === -1) {\n        // limit x -> -1^+ atanh(x) = -Infinity\n        return new Complex(-Infinity, 0);\n      }\n      if (-1 < a && a < 1) {\n        // Purely real\n        return new Complex(0.5 * Math.log((1 + a) / (1 - a)), 0);\n      }\n      if (a > 1) {\n        // Our branch: Im(atanh(a)) = -π/2 for a > 1\n        const t = (a + 1) / (a - 1); // > 0\n        return new Complex(0.5 * Math.log(t), -Math.PI / 2);\n      }\n\n      // a < -1: Im(atanh(a)) = +π/2\n      const t = (1 + a) / (1 - a); // < 0\n      return new Complex(0.5 * Math.log(-t),\n      // log((1 - a)/(1 + a))\n      Math.PI / 2);\n    }\n\n    // Use atanh(z) = 0.5 * Log((1+z)/(1-z)) with principal Log.\n    const oneMinus = 1 - a;\n    const onePlus = 1 + a;\n    const d = oneMinus * oneMinus + b * b; // |1 - z|^2\n\n    if (d === 0) {\n      // (1 - z) == 0 for finite z only at z = 1+0i, already handled above.\n      // If we ever get here, just propagate infinities consistently:\n      return new Complex(a !== -1 ? a / 0 : 0, b !== 0 ? b / 0 : 0);\n    }\n\n    // (1 + z) / (1 - z) with a single complex division\n    const xr = (onePlus * oneMinus - b * b) / d;\n    const xi = (b * oneMinus + onePlus * b) / d;\n\n    // 0.5 * log(xr + i xi)\n    return new Complex(logHypot(xr, xi) / 2, Math.atan2(xi, xr) / 2);\n  },\n  /**\r\n   * Calculate the complex acoth\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'acoth': function () {\n    // acoth(z) = log((z + 1) / (z - 1)) / 2 = atanh(1 / z)\n\n    const a = this['re'];\n    const b = this['im'];\n\n    // z = 0 -> acoth(0) = i * π / 2  (log((1+0)/(1-0))/2 = log(-1)/2)\n    if (a === 0 && b === 0) {\n      return new Complex(0, Math.PI / 2);\n    }\n    const d = a * a + b * b;\n    if (d !== 0) {\n      // 1 / z = (a - i b) / (a^2 + b^2)\n      return new Complex(a / d, -b / d)['atanh']();\n    }\n\n    // Fallback for weird infinities/NaNs: mirror other functions' style\n    return new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0)['atanh']();\n  },\n  /**\r\n   * Calculate the complex acsch\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'acsch': function () {\n    // acsch(c) = log((1+sqrt(1+c^2))/c) = = asinh(1 / z)\n\n    const a = this['re'];\n    const b = this['im'];\n    if (b === 0) {\n      // z = a real\n      if (a === 0) {\n        // acsch(0) -> +/- Infinity, we keep your previous behavior\n        return new Complex(Infinity, 0);\n      }\n\n      // acsch(a) = asinh(1/a) = log(1/a + sqrt(1/a^2 + 1))\n      const inv = 1 / a;\n      return new Complex(Math.log(inv + Math.sqrt(inv * inv + 1)), 0);\n    }\n    const d = a * a + b * b;\n    if (d !== 0) {\n      // 1/z = (a - i b) / (a^2 + b^2)\n      return new Complex(a / d, -b / d)['asinh']();\n    }\n\n    // Handle 0 + 0i or infinities in the same spirit as your existing code\n    return new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0)['asinh']();\n  },\n  /**\r\n   * Calculate the complex asech\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'asech': function () {\n    // asech(z) = acosh(1 / z)\n\n    const a = this['re'];\n    const b = this['im'];\n    if (this['isZero']()) {\n      // asech(0) = acosh(∞) -> ∞\n      return Complex['INFINITY'];\n    }\n    const d = a * a + b * b;\n    if (d !== 0) {\n      // 1 / z = (a - i b) / (a^2 + b^2)\n      return new Complex(a / d, -b / d)['acosh']();\n    }\n\n    // Fallback for weird infinities/NaNs\n    return new Complex(a !== 0 ? a / 0 : 0, b !== 0 ? -b / 0 : 0)['acosh']();\n  },\n  /**\r\n   * Calculate the complex inverse 1/z\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'inverse': function () {\n    // 1 / 0 = Infinity and 1 / Infinity = 0\n    if (this['isZero']()) {\n      return Complex['INFINITY'];\n    }\n    if (this['isInfinite']()) {\n      return Complex['ZERO'];\n    }\n    const a = this['re'];\n    const b = this['im'];\n    const d = a * a + b * b;\n    return new Complex(a / d, -b / d);\n  },\n  /**\r\n   * Returns the complex conjugate\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'conjugate': function () {\n    return new Complex(this['re'], -this['im']);\n  },\n  /**\r\n   * Gets the negated complex number\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'neg': function () {\n    return new Complex(-this['re'], -this['im']);\n  },\n  /**\r\n   * Ceils the actual complex number\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'ceil': function (places) {\n    places = Math.pow(10, places || 0);\n    return new Complex(Math.ceil(this['re'] * places) / places, Math.ceil(this['im'] * places) / places);\n  },\n  /**\r\n   * Floors the actual complex number\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'floor': function (places) {\n    places = Math.pow(10, places || 0);\n    return new Complex(Math.floor(this['re'] * places) / places, Math.floor(this['im'] * places) / places);\n  },\n  /**\r\n   * Ceils the actual complex number\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'round': function (places) {\n    places = Math.pow(10, places || 0);\n    return new Complex(Math.round(this['re'] * places) / places, Math.round(this['im'] * places) / places);\n  },\n  /**\r\n   * Compares two complex numbers\r\n   *\r\n   * **Note:** new Complex(Infinity).equals(Infinity) === false\r\n   *\r\n   * @returns {boolean}\r\n   */\n  'equals': function (a, b) {\n    const z = parse(a, b);\n    return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] && Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];\n  },\n  /**\r\n   * Clones the actual object\r\n   *\r\n   * @returns {Complex}\r\n   */\n  'clone': function () {\n    return new Complex(this['re'], this['im']);\n  },\n  /**\r\n   * Gets a string of the actual complex number\r\n   *\r\n   * @returns {string}\r\n   */\n  'toString': function () {\n    let a = this['re'];\n    let b = this['im'];\n    let ret = \"\";\n    if (this['isNaN']()) {\n      return 'NaN';\n    }\n    if (this['isInfinite']()) {\n      return 'Infinity';\n    }\n    if (Math.abs(a) < Complex['EPSILON']) {\n      a = 0;\n    }\n    if (Math.abs(b) < Complex['EPSILON']) {\n      b = 0;\n    }\n\n    // If is real number\n    if (b === 0) {\n      return ret + a;\n    }\n    if (a !== 0) {\n      ret += a;\n      ret += \" \";\n      if (b < 0) {\n        b = -b;\n        ret += \"-\";\n      } else {\n        ret += \"+\";\n      }\n      ret += \" \";\n    } else if (b < 0) {\n      b = -b;\n      ret += \"-\";\n    }\n    if (1 !== b) {\n      // b is the absolute imaginary part\n      ret += b;\n    }\n    return ret + \"i\";\n  },\n  /**\r\n   * Returns the actual number as a vector\r\n   *\r\n   * @returns {Array}\r\n   */\n  'toVector': function () {\n    return [this['re'], this['im']];\n  },\n  /**\r\n   * Returns the actual real value of the current object\r\n   *\r\n   * @returns {number|null}\r\n   */\n  'valueOf': function () {\n    if (this['im'] === 0) {\n      return this['re'];\n    }\n    return null;\n  },\n  /**\r\n   * Determines whether a complex number is not on the Riemann sphere.\r\n   *\r\n   * @returns {boolean}\r\n   */\n  'isNaN': function () {\n    return isNaN(this['re']) || isNaN(this['im']);\n  },\n  /**\r\n   * Determines whether or not a complex number is at the zero pole of the\r\n   * Riemann sphere.\r\n   *\r\n   * @returns {boolean}\r\n   */\n  'isZero': function () {\n    return this['im'] === 0 && this['re'] === 0;\n  },\n  /**\r\n   * Determines whether a complex number is not at the infinity pole of the\r\n   * Riemann sphere.\r\n   *\r\n   * @returns {boolean}\r\n   */\n  'isFinite': function () {\n    return isFinite(this['re']) && isFinite(this['im']);\n  },\n  /**\r\n   * Determines whether or not a complex number is at the infinity pole of the\r\n   * Riemann sphere.\r\n   *\r\n   * @returns {boolean}\r\n   */\n  'isInfinite': function () {\n    return !this['isFinite']();\n  }\n};\nComplex['ZERO'] = new Complex(0, 0);\nComplex['ONE'] = new Complex(1, 0);\nComplex['I'] = new Complex(0, 1);\nComplex['PI'] = new Complex(Math.PI, 0);\nComplex['E'] = new Complex(Math.E, 0);\nComplex['INFINITY'] = new Complex(Infinity, Infinity);\nComplex['NAN'] = new Complex(NaN, NaN);\nComplex['EPSILON'] = 1e-15;\nexport { Complex as default, Complex };","map":{"version":3,"names":["cosh","Math","x","abs","exp","sinh","cosm1","s","sin","hypot","y","sqrt","parser_exit","SyntaxError","logHypot","a","b","_a","_b","log","LN2","P","parse","z","undefined","isFinite","Complex","cos","length","tokens","replace","match","plus","minus","i","c","isNaN","parseFloat","prototype","sign","add","tInfin","zInfin","sub","mul","tIsZero","zIsZero","div","t","pow","arg","atan2","loh","re","im","r","er","expm1","tan","d","cot","sec","csc","asin","t1","t2","acos","PI","atan","Infinity","acot","asec","acsc","tanh","coth","csch","sech","asinh","re2","im2","acosh","atanh","oneMinus","onePlus","xr","xi","acoth","acsch","inv","asech","inverse","conjugate","neg","ceil","places","floor","round","equals","clone","toString","ret","toVector","valueOf","isZero","isInfinite","E","NaN","default"],"sources":["C:/Users/dudet/Documents/gitexp/CampusEats/node_modules/complex.js/dist/complex.mjs"],"sourcesContent":["'use strict';\r\n\r\n/**\r\n *\r\n * This class allows the manipulation of complex numbers.\r\n * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.\r\n *\r\n * Object form\r\n * { re: <real>, im: <imaginary> }\r\n * { arg: <angle>, abs: <radius> }\r\n * { phi: <angle>, r: <radius> }\r\n *\r\n * Array / Vector form\r\n * [ real, imaginary ]\r\n *\r\n * Double form\r\n * 99.3 - Single double value\r\n *\r\n * String form\r\n * '23.1337' - Simple real number\r\n * '15+3i' - a simple complex number\r\n * '3-i' - a simple complex number\r\n *\r\n * Example:\r\n *\r\n * const c = new Complex('99.3+8i');\r\n * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);\r\n *\r\n */\r\n\r\n\r\nconst cosh = Math.cosh || function (x) {\r\n  return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;\r\n};\r\n\r\nconst sinh = Math.sinh || function (x) {\r\n  return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;\r\n};\r\n\r\n/**\r\n * Calculates cos(x) - 1 using Taylor series if x is small (-¼π ≤ x ≤ ¼π).\r\n *\r\n * @param {number} x\r\n * @returns {number} cos(x) - 1\r\n */\r\nconst cosm1 = x => {\r\n  // cos(x) - 1 = − 2sin^2(x / 2)\r\n  const s = Math.sin(0.5 * x);\r\n  return -2 * s * s;\r\n};\r\n\r\nconst hypot = function (x, y) {\r\n\r\n  x = Math.abs(x);\r\n  y = Math.abs(y);\r\n\r\n  // Ensure `x` is the larger value\r\n  if (x < y) [x, y] = [y, x];\r\n\r\n  // If both are below the threshold, use straightforward Pythagoras\r\n  if (x < 1e8) return Math.sqrt(x * x + y * y);\r\n\r\n  // For larger values, scale to avoid overflow\r\n  y /= x;\r\n  return x * Math.sqrt(1 + y * y);\r\n};\r\n\r\nconst parser_exit = function () {\r\n  throw SyntaxError('Invalid Param');\r\n};\r\n\r\n/**\r\n * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows\r\n *\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number}\r\n */\r\nfunction logHypot(a, b) {\r\n\r\n  const _a = Math.abs(a);\r\n  const _b = Math.abs(b);\r\n\r\n  if (a === 0) {\r\n    return Math.log(_b);\r\n  }\r\n\r\n  if (b === 0) {\r\n    return Math.log(_a);\r\n  }\r\n\r\n  if (_a < 3000 && _b < 3000) {\r\n    return Math.log(a * a + b * b) * 0.5;\r\n  }\r\n\r\n  /* I got 4 ideas to compute this property without overflow:\r\n   *\r\n   * Testing 1000000 times with random samples for a,b ∈ [1, 1000000000] against a big decimal library to get an error estimate\r\n   *\r\n   * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)\r\n\r\n   Math.log(a * a + b * b) / 2\r\n\r\n   *\r\n   *\r\n   * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)\r\n\r\n   const fn = function(a, b) {\r\n   a = Math.abs(a);\r\n   b = Math.abs(b);\r\n   let t = Math.min(a, b);\r\n   a = Math.max(a, b);\r\n   t = t / a;\r\n\r\n   return Math.log(a) + Math.log(1 + t * t) / 2;\r\n   };\r\n\r\n   * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)\r\n\r\n   Math.log(a / Math.cos(Math.atan2(b, a)))\r\n\r\n   * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)\r\n\r\n   Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))\r\n\r\n   */\r\n\r\n  a = a * 0.5;\r\n  b = b * 0.5;\r\n\r\n  return 0.5 * Math.log(a * a + b * b) + Math.LN2;\r\n}\r\n\r\nconst P = { 're': 0, 'im': 0 };\r\nconst parse = function (a, b) {\r\n\r\n  const z = P;\r\n\r\n  if (a === undefined || a === null) {\r\n    z['re'] =\r\n      z['im'] = 0;\r\n  } else if (b !== undefined) {\r\n    z['re'] = a;\r\n    z['im'] = b;\r\n  } else\r\n    switch (typeof a) {\r\n\r\n      case 'object':\r\n\r\n        if ('im' in a && 're' in a) {\r\n          z['re'] = a['re'];\r\n          z['im'] = a['im'];\r\n        } else if ('abs' in a && 'arg' in a) {\r\n          if (!isFinite(a['abs']) && isFinite(a['arg'])) {\r\n            return Complex['INFINITY'];\r\n          }\r\n          z['re'] = a['abs'] * Math.cos(a['arg']);\r\n          z['im'] = a['abs'] * Math.sin(a['arg']);\r\n        } else if ('r' in a && 'phi' in a) {\r\n          if (!isFinite(a['r']) && isFinite(a['phi'])) {\r\n            return Complex['INFINITY'];\r\n          }\r\n          z['re'] = a['r'] * Math.cos(a['phi']);\r\n          z['im'] = a['r'] * Math.sin(a['phi']);\r\n        } else if (a.length === 2) { // Quick array check\r\n          z['re'] = a[0];\r\n          z['im'] = a[1];\r\n        } else {\r\n          parser_exit();\r\n        }\r\n        break;\r\n\r\n      case 'string':\r\n\r\n        z['im'] = /* void */\r\n          z['re'] = 0;\r\n\r\n        const tokens = a.replace(/_/g, '')\r\n          .match(/\\d+\\.?\\d*e[+-]?\\d+|\\d+\\.?\\d*|\\.\\d+|./g);\r\n        let plus = 1;\r\n        let minus = 0;\r\n\r\n        if (tokens === null) {\r\n          parser_exit();\r\n        }\r\n\r\n        for (let i = 0; i < tokens.length; i++) {\r\n\r\n          const c = tokens[i];\r\n\r\n          if (c === ' ' || c === '\\t' || c === '\\n') {\r\n            /* void */\r\n          } else if (c === '+') {\r\n            plus++;\r\n          } else if (c === '-') {\r\n            minus++;\r\n          } else if (c === 'i' || c === 'I') {\r\n\r\n            if (plus + minus === 0) {\r\n              parser_exit();\r\n            }\r\n\r\n            if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {\r\n              z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);\r\n              i++;\r\n            } else {\r\n              z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');\r\n            }\r\n            plus = minus = 0;\r\n\r\n          } else {\r\n\r\n            if (plus + minus === 0 || isNaN(c)) {\r\n              parser_exit();\r\n            }\r\n\r\n            if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {\r\n              z['im'] += parseFloat((minus % 2 ? '-' : '') + c);\r\n              i++;\r\n            } else {\r\n              z['re'] += parseFloat((minus % 2 ? '-' : '') + c);\r\n            }\r\n            plus = minus = 0;\r\n          }\r\n        }\r\n\r\n        // Still something on the stack\r\n        if (plus + minus > 0) {\r\n          parser_exit();\r\n        }\r\n        break;\r\n\r\n      case 'number':\r\n        z['im'] = 0;\r\n        z['re'] = a;\r\n        break;\r\n\r\n      default:\r\n        parser_exit();\r\n    }\r\n\r\n  if (isNaN(z['re']) || isNaN(z['im'])) {\r\n    // If a calculation is NaN, we treat it as NaN and don't throw\r\n    //parser_exit();\r\n  }\r\n\r\n  return z;\r\n};\r\n\r\n/**\r\n * @constructor\r\n * @returns {Complex}\r\n */\r\nfunction Complex(a, b) {\r\n\r\n  if (!(this instanceof Complex)) {\r\n    return new Complex(a, b);\r\n  }\r\n\r\n  const z = parse(a, b);\r\n\r\n  this['re'] = z['re'];\r\n  this['im'] = z['im'];\r\n}\r\n\r\nComplex.prototype = {\r\n\r\n  're': 0,\r\n  'im': 0,\r\n\r\n  /**\r\n   * Calculates the sign of a complex number, which is a normalized complex\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'sign': function () {\r\n\r\n    const abs = hypot(this['re'], this['im']);\r\n\r\n    return new Complex(\r\n      this['re'] / abs,\r\n      this['im'] / abs);\r\n  },\r\n\r\n  /**\r\n   * Adds two complex numbers\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'add': function (a, b) {\r\n\r\n    const z = parse(a, b);\r\n\r\n    const tInfin = this['isInfinite']();\r\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\r\n\r\n    if (tInfin || zInfin) {\r\n\r\n      if (tInfin && zInfin) {\r\n        // Infinity + Infinity = NaN\r\n        return Complex['NAN'];\r\n      }\r\n      // Infinity + z = Infinity { where z != Infinity }\r\n      return Complex['INFINITY'];\r\n    }\r\n\r\n    return new Complex(\r\n      this['re'] + z['re'],\r\n      this['im'] + z['im']);\r\n  },\r\n\r\n  /**\r\n   * Subtracts two complex numbers\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'sub': function (a, b) {\r\n\r\n    const z = parse(a, b);\r\n\r\n    const tInfin = this['isInfinite']();\r\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\r\n\r\n    if (tInfin || zInfin) {\r\n\r\n      if (tInfin && zInfin) {\r\n        // Infinity - Infinity = NaN\r\n        return Complex['NAN'];\r\n      }\r\n      // Infinity - z = Infinity { where z != Infinity }\r\n      return Complex['INFINITY'];\r\n    }\r\n\r\n    return new Complex(\r\n      this['re'] - z['re'],\r\n      this['im'] - z['im']);\r\n  },\r\n\r\n  /**\r\n   * Multiplies two complex numbers\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'mul': function (a, b) {\r\n\r\n    const z = parse(a, b);\r\n\r\n    const tInfin = this['isInfinite']();\r\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\r\n    const tIsZero = this['re'] === 0 && this['im'] === 0;\r\n    const zIsZero = z['re'] === 0 && z['im'] === 0;\r\n\r\n    // Infinity * 0 = NaN\r\n    if (tInfin && zIsZero || zInfin && tIsZero) {\r\n      return Complex['NAN'];\r\n    }\r\n\r\n    // Infinity * z = Infinity { where z != 0 }\r\n    if (tInfin || zInfin) {\r\n      return Complex['INFINITY'];\r\n    }\r\n\r\n    // Shortcut for real values\r\n    if (z['im'] === 0 && this['im'] === 0) {\r\n      return new Complex(this['re'] * z['re'], 0);\r\n    }\r\n\r\n    return new Complex(\r\n      this['re'] * z['re'] - this['im'] * z['im'],\r\n      this['re'] * z['im'] + this['im'] * z['re']);\r\n  },\r\n\r\n  /**\r\n   * Divides two complex numbers\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'div': function (a, b) {\r\n\r\n    const z = parse(a, b);\r\n\r\n    const tInfin = this['isInfinite']();\r\n    const zInfin = !(isFinite(z['re']) && isFinite(z['im']));\r\n    const tIsZero = this['re'] === 0 && this['im'] === 0;\r\n    const zIsZero = z['re'] === 0 && z['im'] === 0;\r\n\r\n    // 0 / 0 = NaN and Infinity / Infinity = NaN\r\n    if (tIsZero && zIsZero || tInfin && zInfin) {\r\n      return Complex['NAN'];\r\n    }\r\n\r\n    // Infinity / 0 = Infinity\r\n    if (zIsZero || tInfin) {\r\n      return Complex['INFINITY'];\r\n    }\r\n\r\n    // 0 / Infinity = 0\r\n    if (tIsZero || zInfin) {\r\n      return Complex['ZERO'];\r\n    }\r\n\r\n    if (0 === z['im']) {\r\n      // Divisor is real\r\n      return new Complex(this['re'] / z['re'], this['im'] / z['re']);\r\n    }\r\n\r\n    if (Math.abs(z['re']) < Math.abs(z['im'])) {\r\n\r\n      const x = z['re'] / z['im'];\r\n      const t = z['re'] * x + z['im'];\r\n\r\n      return new Complex(\r\n        (this['re'] * x + this['im']) / t,\r\n        (this['im'] * x - this['re']) / t);\r\n\r\n    } else {\r\n\r\n      const x = z['im'] / z['re'];\r\n      const t = z['im'] * x + z['re'];\r\n\r\n      return new Complex(\r\n        (this['re'] + this['im'] * x) / t,\r\n        (this['im'] - this['re'] * x) / t);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Calculate the power of two complex numbers\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'pow': function (a, b) {\r\n\r\n    const z = parse(a, b);\r\n\r\n    const tIsZero = this['re'] === 0 && this['im'] === 0;\r\n    const zIsZero = z['re'] === 0 && z['im'] === 0;\r\n\r\n    if (zIsZero) {\r\n      return Complex['ONE'];\r\n    }\r\n\r\n    // If the exponent is real\r\n    if (z['im'] === 0) {\r\n\r\n      if (this['im'] === 0 && this['re'] > 0) {\r\n\r\n        return new Complex(Math.pow(this['re'], z['re']), 0);\r\n\r\n      } else if (this['re'] === 0) { // If base is fully imaginary\r\n\r\n        switch ((z['re'] % 4 + 4) % 4) {\r\n          case 0:\r\n            return new Complex(Math.pow(this['im'], z['re']), 0);\r\n          case 1:\r\n            return new Complex(0, Math.pow(this['im'], z['re']));\r\n          case 2:\r\n            return new Complex(-Math.pow(this['im'], z['re']), 0);\r\n          case 3:\r\n            return new Complex(0, -Math.pow(this['im'], z['re']));\r\n        }\r\n      }\r\n    }\r\n\r\n    /* I couldn't find a good formula, so here is a derivation and optimization\r\n     *\r\n     * z_1^z_2 = (a + bi)^(c + di)\r\n     *         = exp((c + di) * log(a + bi)\r\n     *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))\r\n     * =>...\r\n     * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\r\n     * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))\r\n     *\r\n     * =>...\r\n     * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\r\n     * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))\r\n     *\r\n     * =>\r\n     * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))\r\n     * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))\r\n     *\r\n     */\r\n\r\n    if (tIsZero && z['re'] > 0) { // Same behavior as Wolframalpha, Zero if real part is zero\r\n      return Complex['ZERO'];\r\n    }\r\n\r\n    const arg = Math.atan2(this['im'], this['re']);\r\n    const loh = logHypot(this['re'], this['im']);\r\n\r\n    let re = Math.exp(z['re'] * loh - z['im'] * arg);\r\n    let im = z['im'] * loh + z['re'] * arg;\r\n    return new Complex(\r\n      re * Math.cos(im),\r\n      re * Math.sin(im));\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex square root\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'sqrt': function () {\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    if (b === 0) {\r\n      // Real number case\r\n      if (a >= 0) {\r\n        return new Complex(Math.sqrt(a), 0);\r\n      } else {\r\n        return new Complex(0, Math.sqrt(-a));\r\n      }\r\n    }\r\n\r\n    const r = hypot(a, b);\r\n\r\n    let re = Math.sqrt(0.5 * (r + Math.abs(a))); // sqrt(2x) / 2 = sqrt(x / 2)\r\n    let im = Math.abs(b) / (2 * re);\r\n\r\n    if (a >= 0) {\r\n      return new Complex(re, b < 0 ? -im : im);\r\n    } else {\r\n      return new Complex(im, b < 0 ? -re : re);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex exponent\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'exp': function () {\r\n\r\n    const er = Math.exp(this['re']);\r\n\r\n    if (this['im'] === 0) {\r\n      return new Complex(er, 0);\r\n    }\r\n    return new Complex(\r\n      er * Math.cos(this['im']),\r\n      er * Math.sin(this['im']));\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex exponent and subtracts one.\r\n   *\r\n   * This may be more accurate than `Complex(x).exp().sub(1)` if\r\n   * `x` is small.\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'expm1': function () {\r\n\r\n    /**\r\n     * exp(a + i*b) - 1\r\n     = exp(a) * (cos(b) + j*sin(b)) - 1\r\n     = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)\r\n     */\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    return new Complex(\r\n      Math.expm1(a) * Math.cos(b) + cosm1(b),\r\n      Math.exp(a) * Math.sin(b));\r\n  },\r\n\r\n  /**\r\n   * Calculate the natural log\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'log': function () {\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    if (b === 0 && a > 0) {\r\n      return new Complex(Math.log(a), 0);\r\n    }\r\n\r\n    return new Complex(\r\n      logHypot(a, b),\r\n      Math.atan2(b, a));\r\n  },\r\n\r\n  /**\r\n   * Calculate the magnitude of the complex number\r\n   *\r\n   * @returns {number}\r\n   */\r\n  'abs': function () {\r\n\r\n    return hypot(this['re'], this['im']);\r\n  },\r\n\r\n  /**\r\n   * Calculate the angle of the complex number\r\n   *\r\n   * @returns {number}\r\n   */\r\n  'arg': function () {\r\n\r\n    return Math.atan2(this['im'], this['re']);\r\n  },\r\n\r\n  /**\r\n   * Calculate the sine of the complex number\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'sin': function () {\r\n\r\n    // sin(z) = ( e^iz - e^-iz ) / 2i \r\n    //        = sin(a)cosh(b) + i cos(a)sinh(b)\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    return new Complex(\r\n      Math.sin(a) * cosh(b),\r\n      Math.cos(a) * sinh(b));\r\n  },\r\n\r\n  /**\r\n   * Calculate the cosine\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'cos': function () {\r\n\r\n    // cos(z) = ( e^iz + e^-iz ) / 2 \r\n    //        = cos(a)cosh(b) - i sin(a)sinh(b)\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    return new Complex(\r\n      Math.cos(a) * cosh(b),\r\n      -Math.sin(a) * sinh(b));\r\n  },\r\n\r\n  /**\r\n   * Calculate the tangent\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'tan': function () {\r\n\r\n    // tan(z) = sin(z) / cos(z) \r\n    //        = ( e^iz - e^-iz ) / ( i( e^iz + e^-iz ) )\r\n    //        = ( e^2iz - 1 ) / i( e^2iz + 1 )\r\n    //        = ( sin(2a) + i sinh(2b) ) / ( cos(2a) + cosh(2b) )\r\n\r\n    const a = 2 * this['re'];\r\n    const b = 2 * this['im'];\r\n    const d = Math.cos(a) + cosh(b);\r\n\r\n    return new Complex(\r\n      Math.sin(a) / d,\r\n      sinh(b) / d);\r\n  },\r\n\r\n  /**\r\n   * Calculate the cotangent\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'cot': function () {\r\n\r\n    // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))\r\n\r\n    const a = 2 * this['re'];\r\n    const b = 2 * this['im'];\r\n    const d = Math.cos(a) - cosh(b);\r\n\r\n    return new Complex(\r\n      -Math.sin(a) / d,\r\n      sinh(b) / d);\r\n  },\r\n\r\n  /**\r\n   * Calculate the secant\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'sec': function () {\r\n\r\n    // sec(c) = 2 / (e^(ci) + e^(-ci))\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n    const d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);\r\n\r\n    return new Complex(\r\n      Math.cos(a) * cosh(b) / d,\r\n      Math.sin(a) * sinh(b) / d);\r\n  },\r\n\r\n  /**\r\n   * Calculate the cosecans\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'csc': function () {\r\n\r\n    // csc(c) = 2i / (e^(ci) - e^(-ci))\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n    const d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);\r\n\r\n    return new Complex(\r\n      Math.sin(a) * cosh(b) / d,\r\n      -Math.cos(a) * sinh(b) / d);\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex arcus sinus\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'asin': function () {\r\n\r\n    // asin(c) = -i * log(ci + sqrt(1 - c^2))\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    const t1 = new Complex(\r\n      b * b - a * a + 1,\r\n      -2 * a * b)['sqrt']();\r\n\r\n    const t2 = new Complex(\r\n      t1['re'] - b,\r\n      t1['im'] + a)['log']();\r\n\r\n    return new Complex(t2['im'], -t2['re']);\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex arcus cosinus\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'acos': function () {\r\n\r\n    // acos(c) = i * log(c - i * sqrt(1 - c^2))\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    const t1 = new Complex(\r\n      b * b - a * a + 1,\r\n      -2 * a * b)['sqrt']();\r\n\r\n    const t2 = new Complex(\r\n      t1['re'] - b,\r\n      t1['im'] + a)['log']();\r\n\r\n    return new Complex(Math.PI / 2 - t2['im'], t2['re']);\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex arcus tangent\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'atan': function () {\r\n\r\n    // atan(c) = i / 2 log((i + x) / (i - x))\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    if (a === 0) {\r\n\r\n      if (b === 1) {\r\n        return new Complex(0, Infinity);\r\n      }\r\n\r\n      if (b === -1) {\r\n        return new Complex(0, -Infinity);\r\n      }\r\n    }\r\n\r\n    const d = a * a + (1.0 - b) * (1.0 - b);\r\n\r\n    const t1 = new Complex(\r\n      (1 - b * b - a * a) / d,\r\n      -2 * a / d).log();\r\n\r\n    return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex arcus cotangent\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'acot': function () {\r\n\r\n    // acot(c) = i / 2 log((c - i) / (c + i))\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    if (b === 0) {\r\n      return new Complex(Math.atan2(1, a), 0);\r\n    }\r\n\r\n    const d = a * a + b * b;\r\n    return (d !== 0)\r\n      ? new Complex(\r\n        a / d,\r\n        -b / d).atan()\r\n      : new Complex(\r\n        (a !== 0) ? a / 0 : 0,\r\n        (b !== 0) ? -b / 0 : 0).atan();\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex arcus secant\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'asec': function () {\r\n\r\n    // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    if (a === 0 && b === 0) {\r\n      return new Complex(0, Infinity);\r\n    }\r\n\r\n    const d = a * a + b * b;\r\n    return (d !== 0)\r\n      ? new Complex(\r\n        a / d,\r\n        -b / d).acos()\r\n      : new Complex(\r\n        (a !== 0) ? a / 0 : 0,\r\n        (b !== 0) ? -b / 0 : 0).acos();\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex arcus cosecans\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'acsc': function () {\r\n\r\n    // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    if (a === 0 && b === 0) {\r\n      return new Complex(Math.PI / 2, Infinity);\r\n    }\r\n\r\n    const d = a * a + b * b;\r\n    return (d !== 0)\r\n      ? new Complex(\r\n        a / d,\r\n        -b / d).asin()\r\n      : new Complex(\r\n        (a !== 0) ? a / 0 : 0,\r\n        (b !== 0) ? -b / 0 : 0).asin();\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex sinh\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'sinh': function () {\r\n\r\n    // sinh(c) = (e^c - e^-c) / 2\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    return new Complex(\r\n      sinh(a) * Math.cos(b),\r\n      cosh(a) * Math.sin(b));\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex cosh\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'cosh': function () {\r\n\r\n    // cosh(c) = (e^c + e^-c) / 2\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    return new Complex(\r\n      cosh(a) * Math.cos(b),\r\n      sinh(a) * Math.sin(b));\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex tanh\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'tanh': function () {\r\n\r\n    // tanh(c) = (e^c - e^-c) / (e^c + e^-c)\r\n\r\n    const a = 2 * this['re'];\r\n    const b = 2 * this['im'];\r\n    const d = cosh(a) + Math.cos(b);\r\n\r\n    return new Complex(\r\n      sinh(a) / d,\r\n      Math.sin(b) / d);\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex coth\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'coth': function () {\r\n\r\n    // coth(c) = (e^c + e^-c) / (e^c - e^-c)\r\n\r\n    const a = 2 * this['re'];\r\n    const b = 2 * this['im'];\r\n    const d = cosh(a) - Math.cos(b);\r\n\r\n    return new Complex(\r\n      sinh(a) / d,\r\n      -Math.sin(b) / d);\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex csch\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'csch': function () {\r\n\r\n    // csch(c) = 2 / (e^c - e^-c)\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n    const d = Math.cos(2 * b) - cosh(2 * a);\r\n\r\n    return new Complex(\r\n      -2 * sinh(a) * Math.cos(b) / d,\r\n      2 * cosh(a) * Math.sin(b) / d);\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex sech\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'sech': function () {\r\n\r\n    // sech(c) = 2 / (e^c + e^-c)\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n    const d = Math.cos(2 * b) + cosh(2 * a);\r\n\r\n    return new Complex(\r\n      2 * cosh(a) * Math.cos(b) / d,\r\n      -2 * sinh(a) * Math.sin(b) / d);\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex asinh\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'asinh': function () {\r\n\r\n    // asinh(z) = log(z + sqrt(z^2 + 1))\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    if (b === 0) {\r\n\r\n      if (a === 0) {\r\n        return new Complex(0, 0);\r\n      }\r\n\r\n      // Use |a| to keep asinh(-a) = -asinh(a) and avoid cancellation for large -a\r\n      const x = Math.abs(a);\r\n      const r = Math.log(x + Math.sqrt(x * x + 1));\r\n\r\n      return new Complex(a < 0 ? -r : r, 0);\r\n    }\r\n\r\n    // z^2 + 1 = (a^2 - b^2 + 1) + i (2ab)\r\n    const re2 = a * a - b * b + 1;\r\n    const im2 = 2 * a * b;\r\n\r\n    const t = new Complex(re2, im2)['sqrt'](); // sqrt(z^2 + 1)\r\n\r\n    return new Complex(a + t['re'], b + t['im'])['log']();\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex acosh\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'acosh': function () {\r\n\r\n    // acosh(z)= log(z + sqrt(z^2 - 1)) = log(z + sqrt(z - 1) * sqrt(z + 1))\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    if (b === 0) {\r\n\r\n      // z = a is real\r\n      if (a > 1) {\r\n        // acosh(a) = log(a + sqrt(a - 1) * sqrt(a + 1)),  a > 1\r\n        return new Complex(\r\n          Math.log(a + Math.sqrt(a - 1) * Math.sqrt(a + 1)), 0);\r\n      }\r\n\r\n      if (a < -1) {\r\n        // acosh(a) = log(-a + sqrt(a^2 - 1)) + i*pi,  a < -1\r\n        const t = Math.sqrt(a * a - 1);\r\n        return new Complex(Math.log(-a + t), Math.PI);\r\n      }\r\n\r\n      // -1 <= a <= 1 : purely imaginary\r\n      // acosh(a) = i * acos(a)\r\n      return new Complex(0, Math.acos(a));\r\n    }\r\n\r\n    const t1 = new Complex(a - 1, b)['sqrt'](); // sqrt(z - 1)\r\n    const t2 = new Complex(a + 1, b)['sqrt'](); // sqrt(z + 1)\r\n\r\n    return new Complex(\r\n      a + t1['re'] * t2['re'] - t1['im'] * t2['im'],\r\n      b + t1['re'] * t2['im'] + t1['im'] * t2['re']\r\n    )['log']();\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex atanh\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'atanh': function () {\r\n\r\n    // atanh(z) = log((1 + z) / (1 - z)) / 2\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    if (b === 0) {\r\n\r\n      if (a === 0) {\r\n        return new Complex(0, 0);\r\n      }\r\n\r\n      if (a === 1) {\r\n        // limit x -> 1^- atanh(x) = +Infinity\r\n        return new Complex(Infinity, 0);\r\n      }\r\n\r\n      if (a === -1) {\r\n        // limit x -> -1^+ atanh(x) = -Infinity\r\n        return new Complex(-Infinity, 0);\r\n      }\r\n\r\n      if (-1 < a && a < 1) {\r\n        // Purely real\r\n        return new Complex(\r\n          0.5 * Math.log((1 + a) / (1 - a)),\r\n          0\r\n        );\r\n      }\r\n\r\n      if (a > 1) {\r\n        // Our branch: Im(atanh(a)) = -π/2 for a > 1\r\n        const t = (a + 1) / (a - 1); // > 0\r\n        return new Complex(\r\n          0.5 * Math.log(t),\r\n          -Math.PI / 2\r\n        );\r\n      }\r\n\r\n      // a < -1: Im(atanh(a)) = +π/2\r\n      const t = (1 + a) / (1 - a); // < 0\r\n      return new Complex(\r\n        0.5 * Math.log(-t), // log((1 - a)/(1 + a))\r\n        Math.PI / 2\r\n      );\r\n    }\r\n\r\n    // Use atanh(z) = 0.5 * Log((1+z)/(1-z)) with principal Log.\r\n    const oneMinus = 1 - a;\r\n    const onePlus = 1 + a;\r\n    const d = oneMinus * oneMinus + b * b; // |1 - z|^2\r\n\r\n    if (d === 0) {\r\n      // (1 - z) == 0 for finite z only at z = 1+0i, already handled above.\r\n      // If we ever get here, just propagate infinities consistently:\r\n      return new Complex(\r\n        (a !== -1) ? (a / 0) : 0,\r\n        (b !== 0) ? (b / 0) : 0\r\n      );\r\n    }\r\n\r\n    // (1 + z) / (1 - z) with a single complex division\r\n    const xr = (onePlus * oneMinus - b * b) / d;\r\n    const xi = (b * oneMinus + onePlus * b) / d;\r\n\r\n    // 0.5 * log(xr + i xi)\r\n    return new Complex(\r\n      logHypot(xr, xi) / 2,\r\n      Math.atan2(xi, xr) / 2\r\n    );\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex acoth\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'acoth': function () {\r\n\r\n    // acoth(z) = log((z + 1) / (z - 1)) / 2 = atanh(1 / z)\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    // z = 0 -> acoth(0) = i * π / 2  (log((1+0)/(1-0))/2 = log(-1)/2)\r\n    if (a === 0 && b === 0) {\r\n      return new Complex(0, Math.PI / 2);\r\n    }\r\n\r\n    const d = a * a + b * b;\r\n\r\n    if (d !== 0) {\r\n      // 1 / z = (a - i b) / (a^2 + b^2)\r\n      return new Complex(a / d, -b / d)['atanh']();\r\n    }\r\n\r\n    // Fallback for weird infinities/NaNs: mirror other functions' style\r\n    return new Complex(\r\n      (a !== 0) ? a / 0 : 0,\r\n      (b !== 0) ? -b / 0 : 0\r\n    )['atanh']();\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex acsch\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'acsch': function () {\r\n\r\n    // acsch(c) = log((1+sqrt(1+c^2))/c) = = asinh(1 / z)\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    if (b === 0) {\r\n\r\n      // z = a real\r\n      if (a === 0) {\r\n        // acsch(0) -> +/- Infinity, we keep your previous behavior\r\n        return new Complex(Infinity, 0);\r\n      }\r\n\r\n      // acsch(a) = asinh(1/a) = log(1/a + sqrt(1/a^2 + 1))\r\n      const inv = 1 / a;\r\n      return new Complex(\r\n        Math.log(inv + Math.sqrt(inv * inv + 1)),\r\n        0\r\n      );\r\n    }\r\n\r\n    const d = a * a + b * b;\r\n\r\n    if (d !== 0) {\r\n      // 1/z = (a - i b) / (a^2 + b^2)\r\n      return new Complex(a / d, -b / d)['asinh']();\r\n    }\r\n\r\n    // Handle 0 + 0i or infinities in the same spirit as your existing code\r\n    return new Complex(\r\n      (a !== 0) ? a / 0 : 0,\r\n      (b !== 0) ? -b / 0 : 0)['asinh']();\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex asech\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'asech': function () {\r\n\r\n    // asech(z) = acosh(1 / z)\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    if (this['isZero']()) {\r\n      // asech(0) = acosh(∞) -> ∞\r\n      return Complex['INFINITY'];\r\n    }\r\n\r\n    const d = a * a + b * b;\r\n\r\n    if (d !== 0) {\r\n      // 1 / z = (a - i b) / (a^2 + b^2)\r\n      return new Complex(a / d, -b / d)['acosh']();\r\n    }\r\n\r\n    // Fallback for weird infinities/NaNs\r\n    return new Complex(\r\n      (a !== 0) ? a / 0 : 0,\r\n      (b !== 0) ? -b / 0 : 0)['acosh']();\r\n  },\r\n\r\n  /**\r\n   * Calculate the complex inverse 1/z\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'inverse': function () {\r\n\r\n    // 1 / 0 = Infinity and 1 / Infinity = 0\r\n    if (this['isZero']()) {\r\n      return Complex['INFINITY'];\r\n    }\r\n\r\n    if (this['isInfinite']()) {\r\n      return Complex['ZERO'];\r\n    }\r\n\r\n    const a = this['re'];\r\n    const b = this['im'];\r\n\r\n    const d = a * a + b * b;\r\n\r\n    return new Complex(a / d, -b / d);\r\n  },\r\n\r\n  /**\r\n   * Returns the complex conjugate\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'conjugate': function () {\r\n\r\n    return new Complex(this['re'], -this['im']);\r\n  },\r\n\r\n  /**\r\n   * Gets the negated complex number\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'neg': function () {\r\n\r\n    return new Complex(-this['re'], -this['im']);\r\n  },\r\n\r\n  /**\r\n   * Ceils the actual complex number\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'ceil': function (places) {\r\n\r\n    places = Math.pow(10, places || 0);\r\n\r\n    return new Complex(\r\n      Math.ceil(this['re'] * places) / places,\r\n      Math.ceil(this['im'] * places) / places);\r\n  },\r\n\r\n  /**\r\n   * Floors the actual complex number\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'floor': function (places) {\r\n\r\n    places = Math.pow(10, places || 0);\r\n\r\n    return new Complex(\r\n      Math.floor(this['re'] * places) / places,\r\n      Math.floor(this['im'] * places) / places);\r\n  },\r\n\r\n  /**\r\n   * Ceils the actual complex number\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'round': function (places) {\r\n\r\n    places = Math.pow(10, places || 0);\r\n\r\n    return new Complex(\r\n      Math.round(this['re'] * places) / places,\r\n      Math.round(this['im'] * places) / places);\r\n  },\r\n\r\n  /**\r\n   * Compares two complex numbers\r\n   *\r\n   * **Note:** new Complex(Infinity).equals(Infinity) === false\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  'equals': function (a, b) {\r\n\r\n    const z = parse(a, b);\r\n\r\n    return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] &&\r\n      Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];\r\n  },\r\n\r\n  /**\r\n   * Clones the actual object\r\n   *\r\n   * @returns {Complex}\r\n   */\r\n  'clone': function () {\r\n\r\n    return new Complex(this['re'], this['im']);\r\n  },\r\n\r\n  /**\r\n   * Gets a string of the actual complex number\r\n   *\r\n   * @returns {string}\r\n   */\r\n  'toString': function () {\r\n\r\n    let a = this['re'];\r\n    let b = this['im'];\r\n    let ret = \"\";\r\n\r\n    if (this['isNaN']()) {\r\n      return 'NaN';\r\n    }\r\n\r\n    if (this['isInfinite']()) {\r\n      return 'Infinity';\r\n    }\r\n\r\n    if (Math.abs(a) < Complex['EPSILON']) {\r\n      a = 0;\r\n    }\r\n\r\n    if (Math.abs(b) < Complex['EPSILON']) {\r\n      b = 0;\r\n    }\r\n\r\n    // If is real number\r\n    if (b === 0) {\r\n      return ret + a;\r\n    }\r\n\r\n    if (a !== 0) {\r\n      ret += a;\r\n      ret += \" \";\r\n      if (b < 0) {\r\n        b = -b;\r\n        ret += \"-\";\r\n      } else {\r\n        ret += \"+\";\r\n      }\r\n      ret += \" \";\r\n    } else if (b < 0) {\r\n      b = -b;\r\n      ret += \"-\";\r\n    }\r\n\r\n    if (1 !== b) { // b is the absolute imaginary part\r\n      ret += b;\r\n    }\r\n    return ret + \"i\";\r\n  },\r\n\r\n  /**\r\n   * Returns the actual number as a vector\r\n   *\r\n   * @returns {Array}\r\n   */\r\n  'toVector': function () {\r\n\r\n    return [this['re'], this['im']];\r\n  },\r\n\r\n  /**\r\n   * Returns the actual real value of the current object\r\n   *\r\n   * @returns {number|null}\r\n   */\r\n  'valueOf': function () {\r\n\r\n    if (this['im'] === 0) {\r\n      return this['re'];\r\n    }\r\n    return null;\r\n  },\r\n\r\n  /**\r\n   * Determines whether a complex number is not on the Riemann sphere.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  'isNaN': function () {\r\n    return isNaN(this['re']) || isNaN(this['im']);\r\n  },\r\n\r\n  /**\r\n   * Determines whether or not a complex number is at the zero pole of the\r\n   * Riemann sphere.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  'isZero': function () {\r\n    return this['im'] === 0 && this['re'] === 0;\r\n  },\r\n\r\n  /**\r\n   * Determines whether a complex number is not at the infinity pole of the\r\n   * Riemann sphere.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  'isFinite': function () {\r\n    return isFinite(this['re']) && isFinite(this['im']);\r\n  },\r\n\r\n  /**\r\n   * Determines whether or not a complex number is at the infinity pole of the\r\n   * Riemann sphere.\r\n   *\r\n   * @returns {boolean}\r\n   */\r\n  'isInfinite': function () {\r\n    return !this['isFinite']();\r\n  }\r\n};\r\n\r\nComplex['ZERO'] = new Complex(0, 0);\r\nComplex['ONE'] = new Complex(1, 0);\r\nComplex['I'] = new Complex(0, 1);\r\nComplex['PI'] = new Complex(Math.PI, 0);\r\nComplex['E'] = new Complex(Math.E, 0);\r\nComplex['INFINITY'] = new Complex(Infinity, Infinity);\r\nComplex['NAN'] = new Complex(NaN, NaN);\r\nComplex['EPSILON'] = 1e-15;\r\nexport {\r\n  Complex as default, Complex\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}