{"ast":null,"code":"import { optimizeCallback } from '../../utils/optimizeCallback.js';\nimport { arraySize, broadcastSizes, broadcastTo, get, deepMap } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'map';\nvar dependencies = ['typed'];\nexport var createMap = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\r\n   * Create a new matrix or array with the results of a callback function executed on\r\n   * each entry of a given matrix/array.\r\n   *\r\n   * For each entry of the input,\r\n   *\r\n   * the callback is invoked with 2N + 1 arguments:\r\n   * the N values of the entry, the index at which that entry occurs, and the N full\r\n   * broadcasted matrix/array being traversed where N is the number of matrices being traversed.\r\n   * Note that because the matrix/array might be\r\n   * multidimensional, the \"index\" argument is always an array of numbers giving\r\n   * the index in each dimension. This is true even for vectors: the \"index\"\r\n   * argument is an array of length 1, rather than simply a number.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.map(x, callback)\r\n   *    math.map(x, y, ..., callback)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.map([1, 2, 3], function(value) {\r\n   *      return value * value\r\n   *    })  // returns [1, 4, 9]\r\n   *    math.map([1, 2], [3, 4], function(a, b) {\r\n   *     return a + b\r\n   *    })  // returns [4, 6]\r\n   *\r\n   *    // The callback is normally called with three arguments:\r\n   *    //    callback(value, index, Array)\r\n   *    // If you want to call with only one argument, use:\r\n   *    math.map([1, 2, 3], x => math.format(x)) // returns ['1', '2', '3']\r\n   *    // It can also be called with 2N + 1 arguments: for N arrays\r\n   *    //    callback(value1, value2, index, BroadcastedArray1, BroadcastedArray2)\r\n   *\r\n   * See also:\r\n   *\r\n   *    filter, forEach, sort\r\n   *\r\n   * @param {Matrix | Array} x    The input to iterate on.\r\n   * @param {Function} callback\r\n   *     The function to call (as described above) on each entry of the input\r\n   * @return {Matrix | array}\r\n   *     Transformed map of x; always has the same type and shape as x\r\n   */\n  return typed(name, {\n    'Array, function': _mapArray,\n    'Matrix, function': function Matrix_function(x, callback) {\n      return x.map(callback);\n    },\n    'Array|Matrix, Array|Matrix, ...Array|Matrix|function': (A, B, rest) => _mapMultiple([A, B, ...rest.slice(0, rest.length - 1)], rest[rest.length - 1])\n  });\n\n  /**\r\n  * Maps over multiple arrays or matrices.\r\n  *\r\n  * @param {Array<Array|Matrix>} Arrays - An array of arrays or matrices to map over.\r\n  * @param {function} multiCallback - The callback function to apply to each element.\r\n  * @throws {Error} If the last argument is not a callback function.\r\n  * @returns {Array|Matrix} A new array or matrix with each element being the result of the callback function.\r\n  *\r\n  * @example\r\n  * _mapMultiple([[1, 2, 3], [4, 5, 6]], (a, b) => a + b); // Returns [5, 7, 9]\r\n  */\n  function _mapMultiple(Arrays, multiCallback) {\n    if (typeof multiCallback !== 'function') {\n      throw new Error('Last argument must be a callback function');\n    }\n    var firstArrayIsMatrix = Arrays[0].isMatrix;\n    var sizes = Arrays.map(M => M.isMatrix ? M.size() : arraySize(M));\n    var newSize = broadcastSizes(...sizes);\n    var numberOfArrays = Arrays.length;\n    var _get = firstArrayIsMatrix ? (matrix, idx) => matrix.get(idx) : get;\n    var firstValues = Arrays.map((collection, i) => {\n      var firstIndex = sizes[i].map(() => 0);\n      return collection.isMatrix ? collection.get(firstIndex) : get(collection, firstIndex);\n    });\n    var callbackArgCount = typed.isTypedFunction(multiCallback) ? _getTypedCallbackArgCount(multiCallback, firstValues, newSize.map(() => 0), Arrays) : _getCallbackArgCount(multiCallback, numberOfArrays);\n    if (callbackArgCount < 2) {\n      var _callback = _getLimitedCallback(callbackArgCount, multiCallback, null);\n      return mapMultiple(Arrays, _callback);\n    }\n    var broadcastedArrays = firstArrayIsMatrix ? Arrays.map(M => M.isMatrix ? M.create(broadcastTo(M.toArray(), newSize), M.datatype()) : Arrays[0].create(broadcastTo(M.valueOf(), newSize))) : Arrays.map(M => M.isMatrix ? broadcastTo(M.toArray(), newSize) : broadcastTo(M, newSize));\n    var callback = _getLimitedCallback(callbackArgCount, multiCallback, broadcastedArrays);\n    var broadcastedArraysCallback = (x, idx) => callback([x, ...broadcastedArrays.slice(1).map(array => _get(array, idx))], idx);\n    if (firstArrayIsMatrix) {\n      return broadcastedArrays[0].map(broadcastedArraysCallback);\n    } else {\n      return _mapArray(broadcastedArrays[0], broadcastedArraysCallback);\n    }\n  }\n  function mapMultiple(collections, callback) {\n    // collections can be matrices or arrays\n    // callback must be a function of the form (collections, [index])\n    var firstCollection = collections[0];\n    var arrays = collections.map(collection => collection.isMatrix ? collection.valueOf() : collection);\n    var sizes = collections.map(collection => collection.isMatrix ? collection.size() : arraySize(collection));\n    var finalSize = broadcastSizes(...sizes);\n    // the offset means for each initial array, how much smaller is it than the final size\n    var offsets = sizes.map(size => finalSize.length - size.length);\n    var maxDepth = finalSize.length - 1;\n    var callbackUsesIndex = callback.length > 1;\n    var index = callbackUsesIndex ? [] : null;\n    var resultsArray = iterate(arrays, 0);\n    if (firstCollection.isMatrix) {\n      var resultsMatrix = firstCollection.create();\n      resultsMatrix._data = resultsArray;\n      resultsMatrix._size = finalSize;\n      return resultsMatrix;\n    } else {\n      return resultsArray;\n    }\n    function iterate(arrays) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      // each array can have different sizes\n      var currentDimensionSize = finalSize[depth];\n      var result = Array(currentDimensionSize);\n      if (depth < maxDepth) {\n        var _loop = function _loop(i) {\n          if (index) index[depth] = i;\n          // if there is an offset greater than the current dimension\n          // pass the array, if the size of the array is 1 pass the first\n          // element of the array\n          result[i] = iterate(arrays.map((array, arrayIndex) => offsets[arrayIndex] > depth ? array : array.length === 1 ? array[0] : array[i]), depth + 1);\n        };\n        for (var i = 0; i < currentDimensionSize; i++) {\n          _loop(i);\n        }\n      } else {\n        var _loop2 = function _loop2(_i) {\n          if (index) index[depth] = _i;\n          result[_i] = callback(arrays.map(a => a.length === 1 ? a[0] : a[_i]), index ? index.slice() : undefined);\n        };\n        for (var _i = 0; _i < currentDimensionSize; _i++) {\n          _loop2(_i);\n        }\n      }\n      return result;\n    }\n  }\n\n  /**\r\n    * Creates a limited callback based on the argument pattern.\r\n    * @param {number} callbackArgCount - The argument pattern (0, 1, or 2)\r\n    * @param {Function} multiCallback - The original callback function\r\n    * @param {Array} broadcastedArrays - The broadcasted arrays (for case 2)\r\n    * @returns {Function} The limited callback function\r\n    */\n  function _getLimitedCallback(callbackArgCount, multiCallback, broadcastedArrays) {\n    switch (callbackArgCount) {\n      case 0:\n        return x => multiCallback(...x);\n      case 1:\n        return (x, idx) => multiCallback(...x, idx);\n      case 2:\n        return (x, idx) => multiCallback(...x, idx, ...broadcastedArrays);\n    }\n  }\n\n  /**\r\n     * Determines the argument pattern of a regular callback function.\r\n     * @param {Function} callback - The callback function to analyze\r\n     * @param {number} numberOfArrays - Number of arrays being processed\r\n     * @returns {number} 0 = values only, 1 = values + index, 2 = values + index + arrays\r\n     */\n  function _getCallbackArgCount(callback, numberOfArrays) {\n    var callbackStr = callback.toString();\n    // Check if the callback function uses `arguments`\n    if (/arguments/.test(callbackStr)) return 2;\n\n    // Extract the parameters of the callback function\n    var paramsStr = callbackStr.match(/\\(.*?\\)/);\n    // Check if the callback function uses rest parameters\n    if (/\\.\\.\\./.test(paramsStr)) return 2;\n    if (callback.length > numberOfArrays + 1) {\n      return 2;\n    }\n    if (callback.length === numberOfArrays + 1) {\n      return 1;\n    }\n    return 0;\n  }\n\n  /**\r\n  * Determines the argument pattern of a typed callback function.\r\n  * @param {Function} callback - The typed callback function to analyze\r\n  * @param {Array} values - Sample values for signature resolution\r\n  * @param {Array} idx - Sample index for signature resolution\r\n  * @param {Array} arrays - Sample arrays for signature resolution\r\n  * @returns {number} 0 = values only, 1 = values + index, 2 = values + index + arrays\r\n  */\n\n  function _getTypedCallbackArgCount(callback, values, idx, arrays) {\n    if (typed.resolve(callback, [...values, idx, ...arrays]) !== null) {\n      return 2;\n    }\n    if (typed.resolve(callback, [...values, idx]) !== null) {\n      return 1;\n    }\n    if (typed.resolve(callback, values) !== null) {\n      return 0;\n    }\n    // this should never happen\n    return 0;\n  }\n  /**\r\n  * Map for a multi dimensional array\r\n  * @param {Array} array\r\n  * @param {Function} callback\r\n  * @return {Array}\r\n  * @private\r\n  */\n  function _mapArray(array, callback) {\n    var fastCallback = optimizeCallback(callback, array, name);\n    return deepMap(array, fastCallback.fn, fastCallback.isUnary);\n  }\n});","map":{"version":3,"names":["optimizeCallback","arraySize","broadcastSizes","broadcastTo","get","deepMap","factory","name","dependencies","createMap","_ref","typed","_mapArray","Matrix_function","x","callback","map","Array|Matrix, Array|Matrix, ...Array|Matrix|function","A","B","rest","_mapMultiple","slice","length","Arrays","multiCallback","Error","firstArrayIsMatrix","isMatrix","sizes","M","size","newSize","numberOfArrays","_get","matrix","idx","firstValues","collection","i","firstIndex","callbackArgCount","isTypedFunction","_getTypedCallbackArgCount","_getCallbackArgCount","_callback","_getLimitedCallback","mapMultiple","broadcastedArrays","create","toArray","datatype","valueOf","broadcastedArraysCallback","array","collections","firstCollection","arrays","finalSize","offsets","maxDepth","callbackUsesIndex","index","resultsArray","iterate","resultsMatrix","_data","_size","depth","arguments","undefined","currentDimensionSize","result","Array","_loop","arrayIndex","_loop2","_i","a","callbackStr","toString","test","paramsStr","match","values","resolve","fastCallback","fn","isUnary"],"sources":["C:/Users/dudet/Documents/gitexp/CampusEats/node_modules/mathjs/lib/esm/function/matrix/map.js"],"sourcesContent":["import { optimizeCallback } from '../../utils/optimizeCallback.js';\r\nimport { arraySize, broadcastSizes, broadcastTo, get, deepMap } from '../../utils/array.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'map';\r\nvar dependencies = ['typed'];\r\nexport var createMap = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed\r\n  } = _ref;\r\n  /**\r\n   * Create a new matrix or array with the results of a callback function executed on\r\n   * each entry of a given matrix/array.\r\n   *\r\n   * For each entry of the input,\r\n   *\r\n   * the callback is invoked with 2N + 1 arguments:\r\n   * the N values of the entry, the index at which that entry occurs, and the N full\r\n   * broadcasted matrix/array being traversed where N is the number of matrices being traversed.\r\n   * Note that because the matrix/array might be\r\n   * multidimensional, the \"index\" argument is always an array of numbers giving\r\n   * the index in each dimension. This is true even for vectors: the \"index\"\r\n   * argument is an array of length 1, rather than simply a number.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.map(x, callback)\r\n   *    math.map(x, y, ..., callback)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.map([1, 2, 3], function(value) {\r\n   *      return value * value\r\n   *    })  // returns [1, 4, 9]\r\n   *    math.map([1, 2], [3, 4], function(a, b) {\r\n   *     return a + b\r\n   *    })  // returns [4, 6]\r\n   *\r\n   *    // The callback is normally called with three arguments:\r\n   *    //    callback(value, index, Array)\r\n   *    // If you want to call with only one argument, use:\r\n   *    math.map([1, 2, 3], x => math.format(x)) // returns ['1', '2', '3']\r\n   *    // It can also be called with 2N + 1 arguments: for N arrays\r\n   *    //    callback(value1, value2, index, BroadcastedArray1, BroadcastedArray2)\r\n   *\r\n   * See also:\r\n   *\r\n   *    filter, forEach, sort\r\n   *\r\n   * @param {Matrix | Array} x    The input to iterate on.\r\n   * @param {Function} callback\r\n   *     The function to call (as described above) on each entry of the input\r\n   * @return {Matrix | array}\r\n   *     Transformed map of x; always has the same type and shape as x\r\n   */\r\n  return typed(name, {\r\n    'Array, function': _mapArray,\r\n    'Matrix, function': function Matrix_function(x, callback) {\r\n      return x.map(callback);\r\n    },\r\n    'Array|Matrix, Array|Matrix, ...Array|Matrix|function': (A, B, rest) => _mapMultiple([A, B, ...rest.slice(0, rest.length - 1)], rest[rest.length - 1])\r\n  });\r\n\r\n  /**\r\n  * Maps over multiple arrays or matrices.\r\n  *\r\n  * @param {Array<Array|Matrix>} Arrays - An array of arrays or matrices to map over.\r\n  * @param {function} multiCallback - The callback function to apply to each element.\r\n  * @throws {Error} If the last argument is not a callback function.\r\n  * @returns {Array|Matrix} A new array or matrix with each element being the result of the callback function.\r\n  *\r\n  * @example\r\n  * _mapMultiple([[1, 2, 3], [4, 5, 6]], (a, b) => a + b); // Returns [5, 7, 9]\r\n  */\r\n  function _mapMultiple(Arrays, multiCallback) {\r\n    if (typeof multiCallback !== 'function') {\r\n      throw new Error('Last argument must be a callback function');\r\n    }\r\n    var firstArrayIsMatrix = Arrays[0].isMatrix;\r\n    var sizes = Arrays.map(M => M.isMatrix ? M.size() : arraySize(M));\r\n    var newSize = broadcastSizes(...sizes);\r\n    var numberOfArrays = Arrays.length;\r\n    var _get = firstArrayIsMatrix ? (matrix, idx) => matrix.get(idx) : get;\r\n    var firstValues = Arrays.map((collection, i) => {\r\n      var firstIndex = sizes[i].map(() => 0);\r\n      return collection.isMatrix ? collection.get(firstIndex) : get(collection, firstIndex);\r\n    });\r\n    var callbackArgCount = typed.isTypedFunction(multiCallback) ? _getTypedCallbackArgCount(multiCallback, firstValues, newSize.map(() => 0), Arrays) : _getCallbackArgCount(multiCallback, numberOfArrays);\r\n    if (callbackArgCount < 2) {\r\n      var _callback = _getLimitedCallback(callbackArgCount, multiCallback, null);\r\n      return mapMultiple(Arrays, _callback);\r\n    }\r\n    var broadcastedArrays = firstArrayIsMatrix ? Arrays.map(M => M.isMatrix ? M.create(broadcastTo(M.toArray(), newSize), M.datatype()) : Arrays[0].create(broadcastTo(M.valueOf(), newSize))) : Arrays.map(M => M.isMatrix ? broadcastTo(M.toArray(), newSize) : broadcastTo(M, newSize));\r\n    var callback = _getLimitedCallback(callbackArgCount, multiCallback, broadcastedArrays);\r\n    var broadcastedArraysCallback = (x, idx) => callback([x, ...broadcastedArrays.slice(1).map(array => _get(array, idx))], idx);\r\n    if (firstArrayIsMatrix) {\r\n      return broadcastedArrays[0].map(broadcastedArraysCallback);\r\n    } else {\r\n      return _mapArray(broadcastedArrays[0], broadcastedArraysCallback);\r\n    }\r\n  }\r\n  function mapMultiple(collections, callback) {\r\n    // collections can be matrices or arrays\r\n    // callback must be a function of the form (collections, [index])\r\n    var firstCollection = collections[0];\r\n    var arrays = collections.map(collection => collection.isMatrix ? collection.valueOf() : collection);\r\n    var sizes = collections.map(collection => collection.isMatrix ? collection.size() : arraySize(collection));\r\n    var finalSize = broadcastSizes(...sizes);\r\n    // the offset means for each initial array, how much smaller is it than the final size\r\n    var offsets = sizes.map(size => finalSize.length - size.length);\r\n    var maxDepth = finalSize.length - 1;\r\n    var callbackUsesIndex = callback.length > 1;\r\n    var index = callbackUsesIndex ? [] : null;\r\n    var resultsArray = iterate(arrays, 0);\r\n    if (firstCollection.isMatrix) {\r\n      var resultsMatrix = firstCollection.create();\r\n      resultsMatrix._data = resultsArray;\r\n      resultsMatrix._size = finalSize;\r\n      return resultsMatrix;\r\n    } else {\r\n      return resultsArray;\r\n    }\r\n    function iterate(arrays) {\r\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n      // each array can have different sizes\r\n      var currentDimensionSize = finalSize[depth];\r\n      var result = Array(currentDimensionSize);\r\n      if (depth < maxDepth) {\r\n        var _loop = function _loop(i) {\r\n          if (index) index[depth] = i;\r\n          // if there is an offset greater than the current dimension\r\n          // pass the array, if the size of the array is 1 pass the first\r\n          // element of the array\r\n          result[i] = iterate(arrays.map((array, arrayIndex) => offsets[arrayIndex] > depth ? array : array.length === 1 ? array[0] : array[i]), depth + 1);\r\n        };\r\n        for (var i = 0; i < currentDimensionSize; i++) {\r\n          _loop(i);\r\n        }\r\n      } else {\r\n        var _loop2 = function _loop2(_i) {\r\n          if (index) index[depth] = _i;\r\n          result[_i] = callback(arrays.map(a => a.length === 1 ? a[0] : a[_i]), index ? index.slice() : undefined);\r\n        };\r\n        for (var _i = 0; _i < currentDimensionSize; _i++) {\r\n          _loop2(_i);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n    * Creates a limited callback based on the argument pattern.\r\n    * @param {number} callbackArgCount - The argument pattern (0, 1, or 2)\r\n    * @param {Function} multiCallback - The original callback function\r\n    * @param {Array} broadcastedArrays - The broadcasted arrays (for case 2)\r\n    * @returns {Function} The limited callback function\r\n    */\r\n  function _getLimitedCallback(callbackArgCount, multiCallback, broadcastedArrays) {\r\n    switch (callbackArgCount) {\r\n      case 0:\r\n        return x => multiCallback(...x);\r\n      case 1:\r\n        return (x, idx) => multiCallback(...x, idx);\r\n      case 2:\r\n        return (x, idx) => multiCallback(...x, idx, ...broadcastedArrays);\r\n    }\r\n  }\r\n\r\n  /**\r\n     * Determines the argument pattern of a regular callback function.\r\n     * @param {Function} callback - The callback function to analyze\r\n     * @param {number} numberOfArrays - Number of arrays being processed\r\n     * @returns {number} 0 = values only, 1 = values + index, 2 = values + index + arrays\r\n     */\r\n  function _getCallbackArgCount(callback, numberOfArrays) {\r\n    var callbackStr = callback.toString();\r\n    // Check if the callback function uses `arguments`\r\n    if (/arguments/.test(callbackStr)) return 2;\r\n\r\n    // Extract the parameters of the callback function\r\n    var paramsStr = callbackStr.match(/\\(.*?\\)/);\r\n    // Check if the callback function uses rest parameters\r\n    if (/\\.\\.\\./.test(paramsStr)) return 2;\r\n    if (callback.length > numberOfArrays + 1) {\r\n      return 2;\r\n    }\r\n    if (callback.length === numberOfArrays + 1) {\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n  * Determines the argument pattern of a typed callback function.\r\n  * @param {Function} callback - The typed callback function to analyze\r\n  * @param {Array} values - Sample values for signature resolution\r\n  * @param {Array} idx - Sample index for signature resolution\r\n  * @param {Array} arrays - Sample arrays for signature resolution\r\n  * @returns {number} 0 = values only, 1 = values + index, 2 = values + index + arrays\r\n  */\r\n\r\n  function _getTypedCallbackArgCount(callback, values, idx, arrays) {\r\n    if (typed.resolve(callback, [...values, idx, ...arrays]) !== null) {\r\n      return 2;\r\n    }\r\n    if (typed.resolve(callback, [...values, idx]) !== null) {\r\n      return 1;\r\n    }\r\n    if (typed.resolve(callback, values) !== null) {\r\n      return 0;\r\n    }\r\n    // this should never happen\r\n    return 0;\r\n  }\r\n  /**\r\n  * Map for a multi dimensional array\r\n  * @param {Array} array\r\n  * @param {Function} callback\r\n  * @return {Array}\r\n  * @private\r\n  */\r\n  function _mapArray(array, callback) {\r\n    var fastCallback = optimizeCallback(callback, array, name);\r\n    return deepMap(array, fastCallback.fn, fastCallback.isUnary);\r\n  }\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}